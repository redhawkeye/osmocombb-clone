   1              		.file	"uart.c"
   9              	.Ltext0:
  10              		.cfi_sections	.debug_frame
  11              		.section	.text.uart_set_lcr7bit,"ax",%progbits
  12              		.align	2
  14              	uart_set_lcr7bit:
  15              	.LFB37:
  16              		.file 1 "calypso/uart.c"
   1:calypso/uart.c **** /* Calypso DBB internal UART Driver */
   2:calypso/uart.c **** 
   3:calypso/uart.c **** /* (C) 2010 by Harald Welte <laforge@gnumonks.org>
   4:calypso/uart.c ****  * (C) 2010 by Ingo Albrecht <prom@berlin.ccc.de>
   5:calypso/uart.c ****  *
   6:calypso/uart.c ****  * All Rights Reserved
   7:calypso/uart.c ****  *
   8:calypso/uart.c ****  * This program is free software; you can redistribute it and/or modify
   9:calypso/uart.c ****  * it under the terms of the GNU General Public License as published by
  10:calypso/uart.c ****  * the Free Software Foundation; either version 2 of the License, or
  11:calypso/uart.c ****  * (at your option) any later version.
  12:calypso/uart.c ****  *
  13:calypso/uart.c ****  * This program is distributed in the hope that it will be useful,
  14:calypso/uart.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15:calypso/uart.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  16:calypso/uart.c ****  * GNU General Public License for more details.
  17:calypso/uart.c ****  *
  18:calypso/uart.c ****  * You should have received a copy of the GNU General Public License along
  19:calypso/uart.c ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  20:calypso/uart.c ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  21:calypso/uart.c ****  *
  22:calypso/uart.c ****  */
  23:calypso/uart.c **** 
  24:calypso/uart.c **** #include <debug.h>
  25:calypso/uart.c **** 
  26:calypso/uart.c **** #include <memory.h>
  27:calypso/uart.c **** #include <stdint.h>
  28:calypso/uart.c **** #include <string.h>
  29:calypso/uart.c **** #include <stdio.h>
  30:calypso/uart.c **** 
  31:calypso/uart.c **** #include <defines.h>
  32:calypso/uart.c **** #include <console.h>
  33:calypso/uart.c **** #include <comm/sercomm.h>
  34:calypso/uart.c **** 
  35:calypso/uart.c **** #include <calypso/irq.h>
  36:calypso/uart.c **** #include <uart.h>
  37:calypso/uart.c **** 
  38:calypso/uart.c **** #define BASE_ADDR_UART_MODEM	0xffff5000
  39:calypso/uart.c **** #define OFFSET_IRDA		0x800
  40:calypso/uart.c **** 
  41:calypso/uart.c **** #define UART_REG(n,m)	(BASE_ADDR_UART_MODEM + ((n)*OFFSET_IRDA)+(m))
  42:calypso/uart.c **** 
  43:calypso/uart.c **** #define LCR7BIT		0x80
  44:calypso/uart.c **** #define LCRBFBIT	0x40
  45:calypso/uart.c **** #define MCR6BIT		0x20
  46:calypso/uart.c **** #define REG_OFFS(m)	((m) & ~(LCR7BIT|LCRBFBIT|MCR6BIT))
  47:calypso/uart.c **** /* read access LCR[7] = 0 */
  48:calypso/uart.c **** enum uart_reg {
  49:calypso/uart.c **** 	RHR	= 0,
  50:calypso/uart.c **** 	IER	= 1,
  51:calypso/uart.c **** 	IIR	= 2,
  52:calypso/uart.c **** 	LCR	= 3,
  53:calypso/uart.c **** 	MCR	= 4,
  54:calypso/uart.c **** 	LSR	= 5,
  55:calypso/uart.c **** 	MSR	= 6,
  56:calypso/uart.c **** 	SPR	= 7,
  57:calypso/uart.c **** 	MDR1	= 8,
  58:calypso/uart.c **** 	DMR2	= 9,
  59:calypso/uart.c **** 	SFLSR	= 0x0a,
  60:calypso/uart.c **** 	RESUME	= 0x0b,
  61:calypso/uart.c **** 	SFREGL	= 0x0c,
  62:calypso/uart.c **** 	SFREGH	= 0x0d,
  63:calypso/uart.c **** 	BLR	= 0x0e,
  64:calypso/uart.c **** 	ACREG	= 0x0f,
  65:calypso/uart.c **** 	SCR	= 0x10,
  66:calypso/uart.c **** 	SSR	= 0x11,
  67:calypso/uart.c **** 	EBLR	= 0x12,
  68:calypso/uart.c **** /* read access LCR[7] = 1 */
  69:calypso/uart.c **** 	DLL	= RHR | LCR7BIT,
  70:calypso/uart.c **** 	DLH	= IER | LCR7BIT,
  71:calypso/uart.c **** 	DIV1_6	= ACREG | LCR7BIT,
  72:calypso/uart.c **** /* read/write access LCR[7:0] = 0xbf */
  73:calypso/uart.c **** 	EFR	= IIR | LCRBFBIT,
  74:calypso/uart.c **** 	XON1	= MCR | LCRBFBIT,
  75:calypso/uart.c **** 	XON2	= LSR | LCRBFBIT,
  76:calypso/uart.c **** 	XOFF1	= MSR | LCRBFBIT,
  77:calypso/uart.c **** 	XOFF2 	= SPR | LCRBFBIT,
  78:calypso/uart.c **** /* read/write access if EFR[4] = 1 and MCR[6] = 1 */
  79:calypso/uart.c **** 	TCR	= MSR | MCR6BIT,
  80:calypso/uart.c **** 	TLR	= SPR | MCR6BIT,
  81:calypso/uart.c **** };
  82:calypso/uart.c **** /* write access LCR[7] = 0 */
  83:calypso/uart.c **** #define THR	RHR
  84:calypso/uart.c **** #define FCR	IIR		/* only if EFR[4] = 1 */
  85:calypso/uart.c **** #define TXFLL	SFLSR
  86:calypso/uart.c **** #define TXFLH	RESUME
  87:calypso/uart.c **** #define RXFLL	SFREGL
  88:calypso/uart.c **** #define RXFLH	SFREGH
  89:calypso/uart.c **** 
  90:calypso/uart.c **** enum fcr_bits {
  91:calypso/uart.c **** 	FIFO_EN		= (1 << 0),
  92:calypso/uart.c **** 	RX_FIFO_CLEAR	= (1 << 1),
  93:calypso/uart.c **** 	TX_FIFO_CLEAR	= (1 << 2),
  94:calypso/uart.c **** 	DMA_MODE	= (1 << 3),
  95:calypso/uart.c **** };
  96:calypso/uart.c **** #define TX_FIFO_TRIG_SHIFT	4
  97:calypso/uart.c **** #define RX_FIFO_TRIG_SHIFT	6
  98:calypso/uart.c **** 
  99:calypso/uart.c **** enum iir_bits {
 100:calypso/uart.c **** 	IIR_INT_PENDING			= 0x01,
 101:calypso/uart.c **** 	IIR_INT_TYPE			= 0x3E,
 102:calypso/uart.c **** 	IIR_INT_TYPE_RX_STATUS_ERROR 	= 0x06,
 103:calypso/uart.c **** 	IIR_INT_TYPE_RX_TIMEOUT		= 0x0C,
 104:calypso/uart.c **** 	IIR_INT_TYPE_RHR		= 0x04,
 105:calypso/uart.c **** 	IIR_INT_TYPE_THR		= 0x02,
 106:calypso/uart.c **** 	IIR_INT_TYPE_MSR		= 0x00,
 107:calypso/uart.c **** 	IIR_INT_TYPE_XOFF		= 0x10,
 108:calypso/uart.c **** 	IIR_INT_TYPE_FLOW		= 0x20,
 109:calypso/uart.c **** 	IIR_FCR0_MIRROR			= 0xC0,
 110:calypso/uart.c **** };
 111:calypso/uart.c **** 
 112:calypso/uart.c **** #define UART_REG_UIR	0xffff6000
 113:calypso/uart.c **** 
 114:calypso/uart.c **** /* enable or disable the divisor latch for access to DLL, DLH */
 115:calypso/uart.c **** static void uart_set_lcr7bit(int uart, int on)
 116:calypso/uart.c **** {
  17              		.loc 1 116 0
  18              		.cfi_startproc
  19              		@ args = 0, pretend = 0, frame = 0
  20              		@ frame_needed = 0, uses_anonymous_args = 0
  21              		@ link register save eliminated.
  22              	.LVL0:
 117:calypso/uart.c **** 	uint8_t reg;
 118:calypso/uart.c **** 
 119:calypso/uart.c **** 	reg = readb(UART_REG(uart, LCR));
  23              		.loc 1 119 0
  24 0000 20309FE5 		ldr	r3, .L4
  25 0004 033080E0 		add	r3, r0, r3
  26 0008 8335A0E1 		mov	r3, r3, asl #11
  27 000c 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 120:calypso/uart.c **** 	if (on)
  28              		.loc 1 120 0
  29 0010 000051E3 		cmp	r1, #0
 119:calypso/uart.c **** 	reg = readb(UART_REG(uart, LCR));
  30              		.loc 1 119 0
  31 0014 FF0002E2 		and	r0, r2, #255
  32              	.LVL1:
 121:calypso/uart.c **** 		reg |= (1 << 7);
  33              		.loc 1 121 0
  34 0018 80208013 		orrne	r2, r0, #128
  35              	.LVL2:
 122:calypso/uart.c **** 	else
 123:calypso/uart.c **** 		reg &= ~(1 << 7);
  36              		.loc 1 123 0
  37 001c 7F200202 		andeq	r2, r2, #127
  38              	.LVL3:
 124:calypso/uart.c **** 	writeb(reg, UART_REG(uart, LCR));
  39              		.loc 1 124 0
  40 0020 0320C3E5 		strb	r2, [r3, #3]
 125:calypso/uart.c **** }
  41              		.loc 1 125 0
  42 0024 1EFF2FE1 		bx	lr
  43              	.L5:
  44              		.align	2
  45              	.L4:
  46 0028 EAFF1F00 		.word	2097130
  47              		.cfi_endproc
  48              	.LFE37:
  50              		.section	.text.uart_set_lcr_bf,"ax",%progbits
  51              		.align	2
  53              	uart_set_lcr_bf:
  54              	.LFB38:
 126:calypso/uart.c **** 
 127:calypso/uart.c **** static uint8_t old_lcr;
 128:calypso/uart.c **** static void uart_set_lcr_bf(int uart, int on)
 129:calypso/uart.c **** {
  55              		.loc 1 129 0
  56              		.cfi_startproc
  57              		@ args = 0, pretend = 0, frame = 0
  58              		@ frame_needed = 0, uses_anonymous_args = 0
  59              		@ link register save eliminated.
  60              	.LVL4:
  61 0000 28309FE5 		ldr	r3, .L10
 130:calypso/uart.c **** 	if (on) {
  62              		.loc 1 130 0
  63 0004 000051E3 		cmp	r1, #0
  64 0008 033080E0 		add	r3, r0, r3
  65 000c 20209FE5 		ldr	r2, .L10+4
 131:calypso/uart.c **** 		old_lcr = readb(UART_REG(uart, LCR));
  66              		.loc 1 131 0
  67 0010 8335A011 		movne	r3, r3, asl #11
  68 0014 0310D315 		ldrneb	r1, [r3, #3]	@ zero_extendqisi2
  69              	.LVL5:
 132:calypso/uart.c **** 		writeb(0xBF, UART_REG(uart, LCR));
 133:calypso/uart.c **** 	} else {
 134:calypso/uart.c **** 		writeb(old_lcr, UART_REG(uart, LCR));
  70              		.loc 1 134 0
  71 0018 0020D205 		ldreqb	r2, [r2, #0]	@ zero_extendqisi2
 131:calypso/uart.c **** 		old_lcr = readb(UART_REG(uart, LCR));
  72              		.loc 1 131 0
  73 001c 0010C215 		strneb	r1, [r2, #0]
  74              		.loc 1 134 0
  75 0020 8335A001 		moveq	r3, r3, asl #11
 132:calypso/uart.c **** 		writeb(0xBF, UART_REG(uart, LCR));
  76              		.loc 1 132 0
  77 0024 4020E013 		mvnne	r2, #64
  78              		.loc 1 134 0
  79 0028 0320C3E5 		strb	r2, [r3, #3]
  80 002c 1EFF2FE1 		bx	lr
  81              	.L11:
  82              		.align	2
  83              	.L10:
  84 0030 EAFF1F00 		.word	2097130
  85 0034 00000000 		.word	.LANCHOR0
  86              		.cfi_endproc
  87              	.LFE38:
  89              		.section	.text.uart_set_mcr6bit,"ax",%progbits
  90              		.align	2
  92              	uart_set_mcr6bit:
  93              	.LFB39:
 135:calypso/uart.c **** 	}
 136:calypso/uart.c **** }
 137:calypso/uart.c **** 
 138:calypso/uart.c **** /* Enable or disable the TCR_TLR latch bit in MCR[6] */
 139:calypso/uart.c **** static void uart_set_mcr6bit(int uart, int on)
 140:calypso/uart.c **** {
  94              		.loc 1 140 0
  95              		.cfi_startproc
  96              		@ args = 0, pretend = 0, frame = 0
  97              		@ frame_needed = 0, uses_anonymous_args = 0
  98              		@ link register save eliminated.
  99              	.LVL6:
 141:calypso/uart.c **** 	uint8_t mcr;
 142:calypso/uart.c **** 	/* we assume EFR[4] is always set to 1 */
 143:calypso/uart.c **** 	mcr = readb(UART_REG(uart, MCR));
 100              		.loc 1 143 0
 101 0000 20309FE5 		ldr	r3, .L15
 102 0004 033080E0 		add	r3, r0, r3
 103 0008 8335A0E1 		mov	r3, r3, asl #11
 104 000c 0420D3E5 		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 144:calypso/uart.c **** 	if (on)
 105              		.loc 1 144 0
 106 0010 000051E3 		cmp	r1, #0
 143:calypso/uart.c **** 	mcr = readb(UART_REG(uart, MCR));
 107              		.loc 1 143 0
 108 0014 FF0002E2 		and	r0, r2, #255
 109              	.LVL7:
 145:calypso/uart.c **** 		mcr |= (1 << 6);
 110              		.loc 1 145 0
 111 0018 40208013 		orrne	r2, r0, #64
 112              	.LVL8:
 146:calypso/uart.c **** 	else
 147:calypso/uart.c **** 		mcr &= ~(1 << 6);
 113              		.loc 1 147 0
 114 001c BF200202 		andeq	r2, r2, #191
 115              	.LVL9:
 148:calypso/uart.c **** 	writeb(mcr, UART_REG(uart, MCR));
 116              		.loc 1 148 0
 117 0020 0420C3E5 		strb	r2, [r3, #4]
 149:calypso/uart.c **** }
 118              		.loc 1 149 0
 119 0024 1EFF2FE1 		bx	lr
 120              	.L16:
 121              		.align	2
 122              	.L15:
 123 0028 EAFF1F00 		.word	2097130
 124              		.cfi_endproc
 125              	.LFE39:
 127              		.section	.text.uart_reg_write,"ax",%progbits
 128              		.align	2
 130              	uart_reg_write:
 131              	.LFB40:
 150:calypso/uart.c **** 
 151:calypso/uart.c **** static void uart_reg_write(int uart, enum uart_reg reg, uint8_t val)
 152:calypso/uart.c **** {
 132              		.loc 1 152 0
 133              		.cfi_startproc
 134              		@ args = 0, pretend = 0, frame = 0
 135              		@ frame_needed = 0, uses_anonymous_args = 0
 136              	.LVL10:
 137 0000 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 138              	.LCFI0:
 139              		.cfi_def_cfa_offset 20
 153:calypso/uart.c **** 	if (reg & LCRBFBIT)
 140              		.loc 1 153 0
 141 0004 406011E2 		ands	r6, r1, #64
 142              		.cfi_offset 14, -4
 143              		.cfi_offset 7, -8
 144              		.cfi_offset 6, -12
 145              		.cfi_offset 5, -16
 146              		.cfi_offset 4, -20
 152:calypso/uart.c **** {
 147              		.loc 1 152 0
 148 0008 0050A0E1 		mov	r5, r0
 149 000c 0140A0E1 		mov	r4, r1
 150 0010 0270A0E1 		mov	r7, r2
 151              		.loc 1 153 0
 152 0014 0200000A 		beq	.L18
 154:calypso/uart.c **** 		uart_set_lcr_bf(uart, 1);
 153              		.loc 1 154 0
 154 0018 0110A0E3 		mov	r1, #1
 155              	.LVL11:
 156 001c FEFFFFEB 		bl	uart_set_lcr_bf
 157              	.LVL12:
 158 0020 070000EA 		b	.L19
 159              	.LVL13:
 160              	.L18:
 155:calypso/uart.c **** 	else if (reg & LCR7BIT)
 161              		.loc 1 155 0
 162 0024 800011E3 		tst	r1, #128
 163 0028 0200000A 		beq	.L20
 156:calypso/uart.c **** 		uart_set_lcr7bit(uart, 1);
 164              		.loc 1 156 0
 165 002c 0110A0E3 		mov	r1, #1
 166 0030 FEFFFFEB 		bl	uart_set_lcr7bit
 167              	.LVL14:
 168 0034 020000EA 		b	.L19
 169              	.LVL15:
 170              	.L20:
 157:calypso/uart.c **** 	else if (reg & MCR6BIT)
 171              		.loc 1 157 0
 172 0038 200011E3 		tst	r1, #32
 158:calypso/uart.c **** 		uart_set_mcr6bit(uart, 1);
 173              		.loc 1 158 0
 174 003c 0110A013 		movne	r1, #1
 175 0040 FEFFFF1B 		blne	uart_set_mcr6bit
 176              	.LVL16:
 177              	.L19:
 159:calypso/uart.c **** 
 160:calypso/uart.c **** 	writeb(val, UART_REG(uart, REG_OFFS(reg)));
 178              		.loc 1 160 0
 179 0044 50309FE5 		ldr	r3, .L24
 180 0048 E020C4E3 		bic	r2, r4, #224
 181 004c 033085E0 		add	r3, r5, r3
 161:calypso/uart.c **** 
 162:calypso/uart.c **** 	if (reg & LCRBFBIT)
 182              		.loc 1 162 0
 183 0050 000056E3 		cmp	r6, #0
 160:calypso/uart.c **** 	writeb(val, UART_REG(uart, REG_OFFS(reg)));
 184              		.loc 1 160 0
 185 0054 8375C2E7 		strb	r7, [r2, r3, asl #11]
 186              		.loc 1 162 0
 187 0058 0300000A 		beq	.L21
 163:calypso/uart.c **** 		uart_set_lcr_bf(uart, 0);
 188              		.loc 1 163 0
 189 005c 0500A0E1 		mov	r0, r5
 190 0060 0010A0E3 		mov	r1, #0
 164:calypso/uart.c **** 	else if (reg & LCR7BIT)
 165:calypso/uart.c **** 		uart_set_lcr7bit(uart, 0);
 166:calypso/uart.c **** 	else if (reg & MCR6BIT)
 167:calypso/uart.c **** 		uart_set_mcr6bit(uart, 0);
 168:calypso/uart.c **** }
 191              		.loc 1 168 0
 192 0064 F040BDE8 		ldmfd	sp!, {r4, r5, r6, r7, lr}
 163:calypso/uart.c **** 		uart_set_lcr_bf(uart, 0);
 193              		.loc 1 163 0
 194 0068 FEFFFFEA 		b	uart_set_lcr_bf
 195              	.L21:
 164:calypso/uart.c **** 	else if (reg & LCR7BIT)
 196              		.loc 1 164 0
 197 006c 800014E3 		tst	r4, #128
 198 0070 0300000A 		beq	.L22
 165:calypso/uart.c **** 		uart_set_lcr7bit(uart, 0);
 199              		.loc 1 165 0
 200 0074 0500A0E1 		mov	r0, r5
 201 0078 0610A0E1 		mov	r1, r6
 202              		.loc 1 168 0
 203 007c F040BDE8 		ldmfd	sp!, {r4, r5, r6, r7, lr}
 165:calypso/uart.c **** 		uart_set_lcr7bit(uart, 0);
 204              		.loc 1 165 0
 205 0080 FEFFFFEA 		b	uart_set_lcr7bit
 206              	.L22:
 166:calypso/uart.c **** 	else if (reg & MCR6BIT)
 207              		.loc 1 166 0
 208 0084 200014E3 		tst	r4, #32
 209 0088 F080BD08 		ldmeqfd	sp!, {r4, r5, r6, r7, pc}
 167:calypso/uart.c **** 		uart_set_mcr6bit(uart, 0);
 210              		.loc 1 167 0
 211 008c 0500A0E1 		mov	r0, r5
 212 0090 0610A0E1 		mov	r1, r6
 213              		.loc 1 168 0
 214 0094 F040BDE8 		ldmfd	sp!, {r4, r5, r6, r7, lr}
 167:calypso/uart.c **** 		uart_set_mcr6bit(uart, 0);
 215              		.loc 1 167 0
 216 0098 FEFFFFEA 		b	uart_set_mcr6bit
 217              	.L25:
 218              		.align	2
 219              	.L24:
 220 009c EAFF1F00 		.word	2097130
 221              		.cfi_endproc
 222              	.LFE40:
 224              		.section	.text.uart_reg_read,"ax",%progbits
 225              		.align	2
 227              	uart_reg_read:
 228              	.LFB41:
 169:calypso/uart.c **** 
 170:calypso/uart.c **** /* read from a UART register, applying any required latch bits */
 171:calypso/uart.c **** static uint8_t uart_reg_read(int uart, enum uart_reg reg)
 172:calypso/uart.c **** {
 229              		.loc 1 172 0
 230              		.cfi_startproc
 231              		@ args = 0, pretend = 0, frame = 0
 232              		@ frame_needed = 0, uses_anonymous_args = 0
 233              	.LVL17:
 234 0000 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 235              	.LCFI1:
 236              		.cfi_def_cfa_offset 20
 173:calypso/uart.c **** 	uint8_t ret;
 174:calypso/uart.c **** 
 175:calypso/uart.c **** 	if (reg & LCRBFBIT)
 237              		.loc 1 175 0
 238 0004 406011E2 		ands	r6, r1, #64
 239              		.cfi_offset 14, -4
 240              		.cfi_offset 7, -8
 241              		.cfi_offset 6, -12
 242              		.cfi_offset 5, -16
 243              		.cfi_offset 4, -20
 172:calypso/uart.c **** {
 244              		.loc 1 172 0
 245 0008 0050A0E1 		mov	r5, r0
 246 000c 0140A0E1 		mov	r4, r1
 247              		.loc 1 175 0
 248 0010 0200000A 		beq	.L27
 176:calypso/uart.c **** 		uart_set_lcr_bf(uart, 1);
 249              		.loc 1 176 0
 250 0014 0110A0E3 		mov	r1, #1
 251              	.LVL18:
 252 0018 FEFFFFEB 		bl	uart_set_lcr_bf
 253              	.LVL19:
 254 001c 070000EA 		b	.L28
 255              	.L27:
 177:calypso/uart.c **** 	else if (reg & LCR7BIT)
 256              		.loc 1 177 0
 257 0020 800011E3 		tst	r1, #128
 258 0024 0200000A 		beq	.L29
 178:calypso/uart.c **** 		uart_set_lcr7bit(uart, 1);
 259              		.loc 1 178 0
 260 0028 0110A0E3 		mov	r1, #1
 261 002c FEFFFFEB 		bl	uart_set_lcr7bit
 262 0030 020000EA 		b	.L28
 263              	.L29:
 179:calypso/uart.c **** 	else if (reg & MCR6BIT)
 264              		.loc 1 179 0
 265 0034 200011E3 		tst	r1, #32
 180:calypso/uart.c **** 		uart_set_mcr6bit(uart, 1);
 266              		.loc 1 180 0
 267 0038 0110A013 		movne	r1, #1
 268 003c FEFFFF1B 		blne	uart_set_mcr6bit
 269              	.L28:
 181:calypso/uart.c **** 
 182:calypso/uart.c **** 	ret = readb(UART_REG(uart, REG_OFFS(reg)));
 270              		.loc 1 182 0
 271 0040 54309FE5 		ldr	r3, .L33
 272 0044 E020C4E3 		bic	r2, r4, #224
 273 0048 033085E0 		add	r3, r5, r3
 274 004c 8375D2E7 		ldrb	r7, [r2, r3, asl #11]	@ zero_extendqisi2
 183:calypso/uart.c **** 
 184:calypso/uart.c **** 	if (reg & LCRBFBIT)
 275              		.loc 1 184 0
 276 0050 000056E3 		cmp	r6, #0
 182:calypso/uart.c **** 	ret = readb(UART_REG(uart, REG_OFFS(reg)));
 277              		.loc 1 182 0
 278 0054 FF7007E2 		and	r7, r7, #255
 279              	.LVL20:
 280              		.loc 1 184 0
 281 0058 0300000A 		beq	.L30
 185:calypso/uart.c **** 		uart_set_lcr_bf(uart, 0);
 282              		.loc 1 185 0
 283 005c 0500A0E1 		mov	r0, r5
 284 0060 0010A0E3 		mov	r1, #0
 285 0064 FEFFFFEB 		bl	uart_set_lcr_bf
 286 0068 090000EA 		b	.L31
 287              	.L30:
 186:calypso/uart.c **** 	else if (reg & LCR7BIT)
 288              		.loc 1 186 0
 289 006c 800014E3 		tst	r4, #128
 290 0070 0300000A 		beq	.L32
 187:calypso/uart.c **** 		uart_set_lcr7bit(uart, 0);
 291              		.loc 1 187 0
 292 0074 0500A0E1 		mov	r0, r5
 293 0078 0610A0E1 		mov	r1, r6
 294 007c FEFFFFEB 		bl	uart_set_lcr7bit
 295 0080 030000EA 		b	.L31
 296              	.L32:
 188:calypso/uart.c **** 	else if (reg & MCR6BIT)
 297              		.loc 1 188 0
 298 0084 200014E3 		tst	r4, #32
 189:calypso/uart.c **** 		uart_set_mcr6bit(uart, 0);
 299              		.loc 1 189 0
 300 0088 0500A011 		movne	r0, r5
 301 008c 0610A011 		movne	r1, r6
 302 0090 FEFFFF1B 		blne	uart_set_mcr6bit
 303              	.L31:
 190:calypso/uart.c **** 
 191:calypso/uart.c **** 	return ret;
 192:calypso/uart.c **** }
 304              		.loc 1 192 0
 305 0094 0700A0E1 		mov	r0, r7
 306 0098 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 307              	.L34:
 308              		.align	2
 309              	.L33:
 310 009c EAFF1F00 		.word	2097130
 311              		.cfi_endproc
 312              	.LFE41:
 314              		.section	.text.uart_irq_handler_cons,"ax",%progbits
 315              		.align	2
 317              	uart_irq_handler_cons:
 318              	.LFB42:
 193:calypso/uart.c **** 
 194:calypso/uart.c **** static void uart_irq_handler_cons(__unused enum irq_nr irqnr)
 195:calypso/uart.c **** {
 319              		.loc 1 195 0
 320              		.cfi_startproc
 321              		@ args = 0, pretend = 0, frame = 0
 322              		@ frame_needed = 0, uses_anonymous_args = 0
 323              	.LVL21:
 324 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 325              	.LCFI2:
 326              		.cfi_def_cfa_offset 12
 196:calypso/uart.c **** 	const uint8_t uart = cons_get_uart();
 327              		.loc 1 196 0
 328              		.cfi_offset 14, -4
 329              		.cfi_offset 5, -8
 330              		.cfi_offset 4, -12
 331 0004 FEFFFFEB 		bl	cons_get_uart
 332              	.LVL22:
 197:calypso/uart.c **** 	uint8_t iir;
 198:calypso/uart.c **** 
 199:calypso/uart.c **** 	//uart_putchar_nb(uart, 'U');
 200:calypso/uart.c **** 
 201:calypso/uart.c **** 	iir = uart_reg_read(uart, IIR);
 333              		.loc 1 201 0
 334 0008 FF5000E2 		and	r5, r0, #255
 335 000c 0500A0E1 		mov	r0, r5
 336              	.LVL23:
 337 0010 0210A0E3 		mov	r1, #2
 338 0014 FEFFFFEB 		bl	uart_reg_read
 339              	.LVL24:
 202:calypso/uart.c **** 	if (iir & IIR_INT_PENDING)
 340              		.loc 1 202 0
 341 0018 010010E3 		tst	r0, #1
 342 001c 3080BD18 		ldmnefd	sp!, {r4, r5, pc}
 203:calypso/uart.c **** 		return;
 204:calypso/uart.c **** 
 205:calypso/uart.c **** 	switch (iir & IIR_INT_TYPE) {
 343              		.loc 1 205 0
 344 0020 3E0000E2 		and	r0, r0, #62
 345              	.LVL25:
 346 0024 020050E3 		cmp	r0, #2
 347 0028 3080BD18 		ldmnefd	sp!, {r4, r5, pc}
 206:calypso/uart.c **** 	case IIR_INT_TYPE_RHR:
 207:calypso/uart.c **** 		break;
 208:calypso/uart.c **** 	case IIR_INT_TYPE_THR:
 209:calypso/uart.c **** 		if (cons_rb_flush() == 1) {
 348              		.loc 1 209 0
 349 002c FEFFFFEB 		bl	cons_rb_flush
 350 0030 010050E3 		cmp	r0, #1
 351 0034 0040A0E1 		mov	r4, r0
 352 0038 3080BD18 		ldmnefd	sp!, {r4, r5, pc}
 353              	.LBB2:
 210:calypso/uart.c **** 			/* everything was flushed, disable THR IRQ */
 211:calypso/uart.c **** 			uint8_t ier = uart_reg_read(uart, IER);
 354              		.loc 1 211 0
 355 003c 0410A0E1 		mov	r1, r4
 356 0040 0500A0E1 		mov	r0, r5
 357 0044 FEFFFFEB 		bl	uart_reg_read
 358              	.LVL26:
 212:calypso/uart.c **** 			ier &= ~(1 << 1);
 213:calypso/uart.c **** 			uart_reg_write(uart, IER, ier);
 359              		.loc 1 213 0
 360 0048 0410A0E1 		mov	r1, r4
 361 004c FD2000E2 		and	r2, r0, #253
 362 0050 0500A0E1 		mov	r0, r5
 363              	.LVL27:
 364              	.LBE2:
 214:calypso/uart.c **** 		}
 215:calypso/uart.c **** 		break;
 216:calypso/uart.c **** 	case IIR_INT_TYPE_MSR:
 217:calypso/uart.c **** 		break;
 218:calypso/uart.c **** 	case IIR_INT_TYPE_RX_STATUS_ERROR:
 219:calypso/uart.c **** 		break;
 220:calypso/uart.c **** 	case IIR_INT_TYPE_RX_TIMEOUT:
 221:calypso/uart.c **** 		break;
 222:calypso/uart.c **** 	case IIR_INT_TYPE_XOFF:
 223:calypso/uart.c **** 		break;
 224:calypso/uart.c **** 	}
 225:calypso/uart.c **** }
 365              		.loc 1 225 0
 366 0054 3040BDE8 		ldmfd	sp!, {r4, r5, lr}
 367              	.LBB3:
 213:calypso/uart.c **** 			uart_reg_write(uart, IER, ier);
 368              		.loc 1 213 0
 369 0058 FEFFFFEA 		b	uart_reg_write
 370              	.LBE3:
 371              		.cfi_endproc
 372              	.LFE42:
 374              		.section	.text.uart_irq_enable,"ax",%progbits
 375              		.align	2
 376              		.global	uart_irq_enable
 378              	uart_irq_enable:
 379              	.LFB46:
 226:calypso/uart.c **** 
 227:calypso/uart.c **** static void uart_irq_handler_sercomm(__unused enum irq_nr irqnr)
 228:calypso/uart.c **** {
 229:calypso/uart.c **** 	const uint8_t uart = sercomm_get_uart();
 230:calypso/uart.c **** 	uint8_t iir, ch;
 231:calypso/uart.c **** 
 232:calypso/uart.c **** 	//uart_putchar_nb(uart, 'U');
 233:calypso/uart.c **** 
 234:calypso/uart.c **** 	iir = uart_reg_read(uart, IIR);
 235:calypso/uart.c **** 	if (iir & IIR_INT_PENDING)
 236:calypso/uart.c **** 		return;
 237:calypso/uart.c **** 
 238:calypso/uart.c **** 	switch (iir & IIR_INT_TYPE) {
 239:calypso/uart.c **** 	case IIR_INT_TYPE_RX_TIMEOUT:
 240:calypso/uart.c **** 	case IIR_INT_TYPE_RHR:
 241:calypso/uart.c **** 		/* as long as we have rx data available */
 242:calypso/uart.c **** 		while (uart_getchar_nb(uart, &ch)) {
 243:calypso/uart.c **** 			if (sercomm_drv_rx_char(ch) < 0) {
 244:calypso/uart.c **** 				/* sercomm cannot receive more data right now */
 245:calypso/uart.c **** 				uart_irq_enable(uart, UART_IRQ_RX_CHAR, 0);
 246:calypso/uart.c **** 			}
 247:calypso/uart.c **** 		}
 248:calypso/uart.c **** 		break;
 249:calypso/uart.c **** 	case IIR_INT_TYPE_THR:
 250:calypso/uart.c **** 		/* as long as we have space in the FIFO */
 251:calypso/uart.c **** 		while (!uart_tx_busy(uart)) {
 252:calypso/uart.c **** 			/* get a byte from sercomm */
 253:calypso/uart.c **** 			if (!sercomm_drv_pull(&ch)) {
 254:calypso/uart.c **** 				/* no more bytes in sercomm, stop TX interrupts */
 255:calypso/uart.c **** 				uart_irq_enable(uart, UART_IRQ_TX_EMPTY, 0);
 256:calypso/uart.c **** 				break;
 257:calypso/uart.c **** 			}
 258:calypso/uart.c **** 			/* write the byte into the TX FIFO */
 259:calypso/uart.c **** 			uart_putchar_nb(uart, ch);
 260:calypso/uart.c **** 		}
 261:calypso/uart.c **** 		break;
 262:calypso/uart.c **** 	case IIR_INT_TYPE_MSR:
 263:calypso/uart.c **** 		printf("UART IRQ MSR\n");
 264:calypso/uart.c **** 		break;
 265:calypso/uart.c **** 	case IIR_INT_TYPE_RX_STATUS_ERROR:
 266:calypso/uart.c **** 		printf("UART IRQ RX_SE\n");
 267:calypso/uart.c **** 		break;
 268:calypso/uart.c **** 	case IIR_INT_TYPE_XOFF:
 269:calypso/uart.c **** 		printf("UART IRQXOFF\n");
 270:calypso/uart.c **** 		break;
 271:calypso/uart.c **** 	}
 272:calypso/uart.c **** }
 273:calypso/uart.c **** 
 274:calypso/uart.c **** static const uint8_t uart2irq[] = {
 275:calypso/uart.c **** 	[0]	= IRQ_UART_IRDA,
 276:calypso/uart.c **** 	[1]	= IRQ_UART_MODEM,
 277:calypso/uart.c **** };
 278:calypso/uart.c **** 
 279:calypso/uart.c **** void uart_init(uint8_t uart, uint8_t interrupts)
 280:calypso/uart.c **** {
 281:calypso/uart.c **** 	uint8_t irq = uart2irq[uart];
 282:calypso/uart.c **** 
 283:calypso/uart.c **** 	uart_reg_write(uart, IER, 0x00);
 284:calypso/uart.c **** 	if (uart == cons_get_uart()) {
 285:calypso/uart.c **** 		cons_init();
 286:calypso/uart.c **** 		if(interrupts) {
 287:calypso/uart.c **** 			irq_register_handler(irq, &uart_irq_handler_cons);
 288:calypso/uart.c **** 			irq_config(irq, 0, 0, 0xff);
 289:calypso/uart.c **** 			irq_enable(irq);
 290:calypso/uart.c **** 		}
 291:calypso/uart.c **** 	} else if (uart == sercomm_get_uart()) {
 292:calypso/uart.c **** 		sercomm_init();
 293:calypso/uart.c **** 		if(interrupts) {
 294:calypso/uart.c **** 			irq_register_handler(irq, &uart_irq_handler_sercomm);
 295:calypso/uart.c **** 			irq_config(irq, 0, 0, 0xff);
 296:calypso/uart.c **** 			irq_enable(irq);
 297:calypso/uart.c **** 		}
 298:calypso/uart.c **** 		uart_irq_enable(uart, UART_IRQ_RX_CHAR, 1);
 299:calypso/uart.c **** 	} else {
 300:calypso/uart.c **** 		return;
 301:calypso/uart.c **** 	}
 302:calypso/uart.c **** #if 0
 303:calypso/uart.c **** 	if (uart == 1) {
 304:calypso/uart.c **** 		/* assign UART to MCU and unmask interrupts*/
 305:calypso/uart.c **** 		writeb(UART_REG_UIR, 0x00);
 306:calypso/uart.c **** 	}
 307:calypso/uart.c **** #endif
 308:calypso/uart.c **** 
 309:calypso/uart.c **** 	/* if we don't initialize these, we get strange corruptions in the
 310:calypso/uart.c **** 	   received data... :-( */
 311:calypso/uart.c **** 	uart_reg_write(uart,  MDR1, 0x07); /* turn off UART */
 312:calypso/uart.c **** 	uart_reg_write(uart,  XON1, 0x00); /* Xon1/Addr Register */
 313:calypso/uart.c **** 	uart_reg_write(uart,  XON2, 0x00); /* Xon2/Addr Register */
 314:calypso/uart.c **** 	uart_reg_write(uart, XOFF1, 0x00); /* Xoff1 Register */
 315:calypso/uart.c **** 	uart_reg_write(uart, XOFF2, 0x00); /* Xoff2 Register */
 316:calypso/uart.c **** 	uart_reg_write(uart,   EFR, 0x00); /* Enhanced Features Register */
 317:calypso/uart.c **** 
 318:calypso/uart.c **** 	/* select  UART mode */
 319:calypso/uart.c **** 	uart_reg_write(uart, MDR1, 0);
 320:calypso/uart.c **** 	/* no XON/XOFF flow control, ENHANCED_EN, no auto-RTS/CTS */
 321:calypso/uart.c **** 	uart_reg_write(uart, EFR, (1 << 4));
 322:calypso/uart.c **** 	/* enable Tx/Rx FIFO, Tx trigger at 56 spaces, Rx trigger at 60 chars */
 323:calypso/uart.c **** 	uart_reg_write(uart, FCR, FIFO_EN | RX_FIFO_CLEAR | TX_FIFO_CLEAR |
 324:calypso/uart.c **** 			(3 << TX_FIFO_TRIG_SHIFT) | (3 << RX_FIFO_TRIG_SHIFT));
 325:calypso/uart.c **** 
 326:calypso/uart.c **** 	/* THR interrupt only when TX FIFO and TX shift register are empty */
 327:calypso/uart.c **** 	uart_reg_write(uart, SCR, (1 << 0));// | (1 << 3));
 328:calypso/uart.c **** 
 329:calypso/uart.c **** 	/* 8 bit, 1 stop bit, no parity, no break */
 330:calypso/uart.c **** 	uart_reg_write(uart, LCR, 0x03);
 331:calypso/uart.c **** 
 332:calypso/uart.c **** 	uart_set_lcr7bit(uart, 0);
 333:calypso/uart.c **** }
 334:calypso/uart.c **** 
 335:calypso/uart.c **** void uart_poll(uint8_t uart) {
 336:calypso/uart.c **** 	if(uart == cons_get_uart()) {
 337:calypso/uart.c **** 		uart_irq_handler_cons(0);
 338:calypso/uart.c **** 	} else {
 339:calypso/uart.c **** 		uart_irq_handler_sercomm(0);
 340:calypso/uart.c **** 	}
 341:calypso/uart.c **** }
 342:calypso/uart.c **** 
 343:calypso/uart.c **** void uart_irq_enable(uint8_t uart, enum uart_irq irq, int on)
 344:calypso/uart.c **** {
 380              		.loc 1 344 0
 381              		.cfi_startproc
 382              		@ args = 0, pretend = 0, frame = 0
 383              		@ frame_needed = 0, uses_anonymous_args = 0
 384              	.LVL28:
 385 0000 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 386              	.LCFI3:
 387              		.cfi_def_cfa_offset 16
 388              		.loc 1 344 0
 389 0004 FF5000E2 		and	r5, r0, #255
 390              		.cfi_offset 14, -4
 391              		.cfi_offset 6, -8
 392              		.cfi_offset 5, -12
 393              		.cfi_offset 4, -16
 394 0008 0140A0E1 		mov	r4, r1
 345:calypso/uart.c **** 	uint8_t ier = uart_reg_read(uart, IER);
 395              		.loc 1 345 0
 396 000c 0500A0E1 		mov	r0, r5
 397              	.LVL29:
 398 0010 0110A0E3 		mov	r1, #1
 399              	.LVL30:
 344:calypso/uart.c **** {
 400              		.loc 1 344 0
 401 0014 0260A0E1 		mov	r6, r2
 402              		.loc 1 345 0
 403 0018 FEFFFFEB 		bl	uart_reg_read
 404              	.LVL31:
 405 001c 010054E3 		cmp	r4, #1
 406 0020 24309F95 		ldrls	r3, .L44
 407 0024 0430D397 		ldrlsb	r3, [r3, r4]	@ zero_extendqisi2
 408 0028 0030A083 		movhi	r3, #0
 409              	.LVL32:
 346:calypso/uart.c **** 	uint8_t mask = 0;
 347:calypso/uart.c **** 
 348:calypso/uart.c **** 	switch (irq) {
 349:calypso/uart.c **** 	case UART_IRQ_TX_EMPTY:
 350:calypso/uart.c **** 		mask = (1 << 1);
 351:calypso/uart.c **** 		break;
 352:calypso/uart.c **** 	case UART_IRQ_RX_CHAR:
 353:calypso/uart.c **** 		mask = (1 << 0);
 354:calypso/uart.c **** 		break;
 355:calypso/uart.c **** 	}
 356:calypso/uart.c **** 
 357:calypso/uart.c **** 	if (on)
 410              		.loc 1 357 0
 411 002c 000056E3 		cmp	r6, #0
 358:calypso/uart.c **** 		ier |= mask;
 412              		.loc 1 358 0
 413 0030 00208311 		orrne	r2, r3, r0
 359:calypso/uart.c **** 	else
 360:calypso/uart.c **** 		ier &= ~mask;
 414              		.loc 1 360 0
 415 0034 0320C001 		biceq	r2, r0, r3
 416 0038 FF2002E2 		and	r2, r2, #255
 417              	.LVL33:
 361:calypso/uart.c **** 
 362:calypso/uart.c **** 	uart_reg_write(uart, IER, ier);
 418              		.loc 1 362 0
 419 003c 0500A0E1 		mov	r0, r5
 420 0040 0110A0E3 		mov	r1, #1
 363:calypso/uart.c **** }
 421              		.loc 1 363 0
 422 0044 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 362:calypso/uart.c **** 	uart_reg_write(uart, IER, ier);
 423              		.loc 1 362 0
 424 0048 FEFFFFEA 		b	uart_reg_write
 425              	.LVL34:
 426              	.L45:
 427              		.align	2
 428              	.L44:
 429 004c 00000000 		.word	.LANCHOR1
 430              		.cfi_endproc
 431              	.LFE46:
 433              		.section	.text.uart_init,"ax",%progbits
 434              		.align	2
 435              		.global	uart_init
 437              	uart_init:
 438              	.LFB44:
 280:calypso/uart.c **** {
 439              		.loc 1 280 0
 440              		.cfi_startproc
 441              		@ args = 0, pretend = 0, frame = 0
 442              		@ frame_needed = 0, uses_anonymous_args = 0
 443              	.LVL35:
 281:calypso/uart.c **** 	uint8_t irq = uart2irq[uart];
 444              		.loc 1 281 0
 445 0000 74319FE5 		ldr	r3, .L51
 280:calypso/uart.c **** {
 446              		.loc 1 280 0
 447 0004 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 448              	.LCFI4:
 449              		.cfi_def_cfa_offset 16
 280:calypso/uart.c **** {
 450              		.loc 1 280 0
 451 0008 FF4000E2 		and	r4, r0, #255
 452              		.cfi_offset 14, -4
 453              		.cfi_offset 6, -8
 454              		.cfi_offset 5, -12
 455              		.cfi_offset 4, -16
 281:calypso/uart.c **** 	uint8_t irq = uart2irq[uart];
 456              		.loc 1 281 0
 457 000c 043083E0 		add	r3, r3, r4
 283:calypso/uart.c **** 	uart_reg_write(uart, IER, 0x00);
 458              		.loc 1 283 0
 459 0010 0400A0E1 		mov	r0, r4
 460              	.LVL36:
 461 0014 0020A0E3 		mov	r2, #0
 280:calypso/uart.c **** {
 462              		.loc 1 280 0
 463 0018 FF6001E2 		and	r6, r1, #255
 283:calypso/uart.c **** 	uart_reg_write(uart, IER, 0x00);
 464              		.loc 1 283 0
 465 001c 0110A0E3 		mov	r1, #1
 466              	.LVL37:
 281:calypso/uart.c **** 	uint8_t irq = uart2irq[uart];
 467              		.loc 1 281 0
 468 0020 0450D3E5 		ldrb	r5, [r3, #4]	@ zero_extendqisi2
 469              	.LVL38:
 283:calypso/uart.c **** 	uart_reg_write(uart, IER, 0x00);
 470              		.loc 1 283 0
 471 0024 FEFFFFEB 		bl	uart_reg_write
 284:calypso/uart.c **** 	if (uart == cons_get_uart()) {
 472              		.loc 1 284 0
 473 0028 FEFFFFEB 		bl	cons_get_uart
 474 002c 000054E1 		cmp	r4, r0
 475 0030 0D00001A 		bne	.L47
 285:calypso/uart.c **** 		cons_init();
 476              		.loc 1 285 0
 477 0034 FEFFFFEB 		bl	cons_init
 286:calypso/uart.c **** 		if(interrupts) {
 478              		.loc 1 286 0
 479 0038 000056E3 		cmp	r6, #0
 480 003c 1E00000A 		beq	.L48
 287:calypso/uart.c **** 			irq_register_handler(irq, &uart_irq_handler_cons);
 481              		.loc 1 287 0
 482 0040 0500A0E1 		mov	r0, r5
 483 0044 34119FE5 		ldr	r1, .L51+4
 484 0048 FEFFFFEB 		bl	irq_register_handler
 288:calypso/uart.c **** 			irq_config(irq, 0, 0, 0xff);
 485              		.loc 1 288 0
 486 004c 0010A0E3 		mov	r1, #0
 487 0050 0500A0E1 		mov	r0, r5
 488 0054 0120A0E1 		mov	r2, r1
 489 0058 0030E0E3 		mvn	r3, #0
 490 005c FEFFFFEB 		bl	irq_config
 289:calypso/uart.c **** 			irq_enable(irq);
 491              		.loc 1 289 0
 492 0060 0500A0E1 		mov	r0, r5
 493 0064 FEFFFFEB 		bl	irq_enable
 494 0068 130000EA 		b	.L48
 495              	.L47:
 291:calypso/uart.c **** 	} else if (uart == sercomm_get_uart()) {
 496              		.loc 1 291 0
 497 006c FEFFFFEB 		bl	sercomm_get_uart
 498 0070 000054E1 		cmp	r4, r0
 499 0074 7080BD18 		ldmnefd	sp!, {r4, r5, r6, pc}
 292:calypso/uart.c **** 		sercomm_init();
 500              		.loc 1 292 0
 501 0078 FEFFFFEB 		bl	sercomm_init
 293:calypso/uart.c **** 		if(interrupts) {
 502              		.loc 1 293 0
 503 007c 000056E3 		cmp	r6, #0
 504 0080 0900000A 		beq	.L50
 294:calypso/uart.c **** 			irq_register_handler(irq, &uart_irq_handler_sercomm);
 505              		.loc 1 294 0
 506 0084 0500A0E1 		mov	r0, r5
 507 0088 F4109FE5 		ldr	r1, .L51+8
 508 008c FEFFFFEB 		bl	irq_register_handler
 295:calypso/uart.c **** 			irq_config(irq, 0, 0, 0xff);
 509              		.loc 1 295 0
 510 0090 0010A0E3 		mov	r1, #0
 511 0094 0500A0E1 		mov	r0, r5
 512 0098 0120A0E1 		mov	r2, r1
 513 009c 0030E0E3 		mvn	r3, #0
 514 00a0 FEFFFFEB 		bl	irq_config
 296:calypso/uart.c **** 			irq_enable(irq);
 515              		.loc 1 296 0
 516 00a4 0500A0E1 		mov	r0, r5
 517 00a8 FEFFFFEB 		bl	irq_enable
 518              	.L50:
 298:calypso/uart.c **** 		uart_irq_enable(uart, UART_IRQ_RX_CHAR, 1);
 519              		.loc 1 298 0
 520 00ac 0110A0E3 		mov	r1, #1
 521 00b0 0400A0E1 		mov	r0, r4
 522 00b4 0120A0E1 		mov	r2, r1
 523 00b8 FEFFFFEB 		bl	uart_irq_enable
 524              	.L48:
 311:calypso/uart.c **** 	uart_reg_write(uart,  MDR1, 0x07); /* turn off UART */
 525              		.loc 1 311 0
 526 00bc 0400A0E1 		mov	r0, r4
 527 00c0 0810A0E3 		mov	r1, #8
 528 00c4 0720A0E3 		mov	r2, #7
 529 00c8 FEFFFFEB 		bl	uart_reg_write
 312:calypso/uart.c **** 	uart_reg_write(uart,  XON1, 0x00); /* Xon1/Addr Register */
 530              		.loc 1 312 0
 531 00cc 0400A0E1 		mov	r0, r4
 532 00d0 4410A0E3 		mov	r1, #68
 533 00d4 0020A0E3 		mov	r2, #0
 534 00d8 FEFFFFEB 		bl	uart_reg_write
 313:calypso/uart.c **** 	uart_reg_write(uart,  XON2, 0x00); /* Xon2/Addr Register */
 535              		.loc 1 313 0
 536 00dc 0400A0E1 		mov	r0, r4
 537 00e0 4510A0E3 		mov	r1, #69
 538 00e4 0020A0E3 		mov	r2, #0
 539 00e8 FEFFFFEB 		bl	uart_reg_write
 314:calypso/uart.c **** 	uart_reg_write(uart, XOFF1, 0x00); /* Xoff1 Register */
 540              		.loc 1 314 0
 541 00ec 0400A0E1 		mov	r0, r4
 542 00f0 4610A0E3 		mov	r1, #70
 543 00f4 0020A0E3 		mov	r2, #0
 544 00f8 FEFFFFEB 		bl	uart_reg_write
 315:calypso/uart.c **** 	uart_reg_write(uart, XOFF2, 0x00); /* Xoff2 Register */
 545              		.loc 1 315 0
 546 00fc 0400A0E1 		mov	r0, r4
 547 0100 4710A0E3 		mov	r1, #71
 548 0104 0020A0E3 		mov	r2, #0
 549 0108 FEFFFFEB 		bl	uart_reg_write
 316:calypso/uart.c **** 	uart_reg_write(uart,   EFR, 0x00); /* Enhanced Features Register */
 550              		.loc 1 316 0
 551 010c 0400A0E1 		mov	r0, r4
 552 0110 4210A0E3 		mov	r1, #66
 553 0114 0020A0E3 		mov	r2, #0
 554 0118 FEFFFFEB 		bl	uart_reg_write
 319:calypso/uart.c **** 	uart_reg_write(uart, MDR1, 0);
 555              		.loc 1 319 0
 556 011c 0400A0E1 		mov	r0, r4
 557 0120 0810A0E3 		mov	r1, #8
 558 0124 0020A0E3 		mov	r2, #0
 559 0128 FEFFFFEB 		bl	uart_reg_write
 321:calypso/uart.c **** 	uart_reg_write(uart, EFR, (1 << 4));
 560              		.loc 1 321 0
 561 012c 0400A0E1 		mov	r0, r4
 562 0130 4210A0E3 		mov	r1, #66
 563 0134 1020A0E3 		mov	r2, #16
 564 0138 FEFFFFEB 		bl	uart_reg_write
 323:calypso/uart.c **** 	uart_reg_write(uart, FCR, FIFO_EN | RX_FIFO_CLEAR | TX_FIFO_CLEAR |
 565              		.loc 1 323 0
 566 013c 0400A0E1 		mov	r0, r4
 567 0140 0210A0E3 		mov	r1, #2
 568 0144 F720A0E3 		mov	r2, #247
 569 0148 FEFFFFEB 		bl	uart_reg_write
 327:calypso/uart.c **** 	uart_reg_write(uart, SCR, (1 << 0));// | (1 << 3));
 570              		.loc 1 327 0
 571 014c 0400A0E1 		mov	r0, r4
 572 0150 1010A0E3 		mov	r1, #16
 573 0154 0120A0E3 		mov	r2, #1
 574 0158 FEFFFFEB 		bl	uart_reg_write
 330:calypso/uart.c **** 	uart_reg_write(uart, LCR, 0x03);
 575              		.loc 1 330 0
 576 015c 0310A0E3 		mov	r1, #3
 577 0160 0400A0E1 		mov	r0, r4
 578 0164 0120A0E1 		mov	r2, r1
 579 0168 FEFFFFEB 		bl	uart_reg_write
 332:calypso/uart.c **** 	uart_set_lcr7bit(uart, 0);
 580              		.loc 1 332 0
 581 016c 0400A0E1 		mov	r0, r4
 582 0170 0010A0E3 		mov	r1, #0
 333:calypso/uart.c **** }
 583              		.loc 1 333 0
 584 0174 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 332:calypso/uart.c **** 	uart_set_lcr7bit(uart, 0);
 585              		.loc 1 332 0
 586 0178 FEFFFFEA 		b	uart_set_lcr7bit
 587              	.L52:
 588              		.align	2
 589              	.L51:
 590 017c 00000000 		.word	.LANCHOR1
 591 0180 00000000 		.word	uart_irq_handler_cons
 592 0184 00000000 		.word	uart_irq_handler_sercomm
 593              		.cfi_endproc
 594              	.LFE44:
 596              		.section	.text.uart_putchar_wait,"ax",%progbits
 597              		.align	2
 598              		.global	uart_putchar_wait
 600              	uart_putchar_wait:
 601              	.LFB47:
 364:calypso/uart.c **** 
 365:calypso/uart.c **** 
 366:calypso/uart.c **** void uart_putchar_wait(uint8_t uart, int c)
 367:calypso/uart.c **** {
 602              		.loc 1 367 0
 603              		.cfi_startproc
 604              		@ args = 0, pretend = 0, frame = 0
 605              		@ frame_needed = 0, uses_anonymous_args = 0
 606              		@ link register save eliminated.
 607              	.LVL39:
 368:calypso/uart.c **** 	/* wait while TX FIFO indicates full */
 369:calypso/uart.c **** 	while (readb(UART_REG(uart, SSR)) & 0x01) { }
 608              		.loc 1 369 0
 609 0000 24309FE5 		ldr	r3, .L56
 367:calypso/uart.c **** {
 610              		.loc 1 367 0
 611 0004 FF0000E2 		and	r0, r0, #255
 612              	.LVL40:
 613              		.loc 1 369 0
 614 0008 033080E0 		add	r3, r0, r3
 615 000c 8335A0E1 		mov	r3, r3, asl #11
 616 0010 112083E2 		add	r2, r3, #17
 617              	.L54:
 618              		.loc 1 369 0 is_stmt 0 discriminator 1
 619 0014 0000D2E5 		ldrb	r0, [r2, #0]	@ zero_extendqisi2
 620 0018 010010E3 		tst	r0, #1
 621 001c FCFFFF1A 		bne	.L54
 370:calypso/uart.c **** 
 371:calypso/uart.c **** 	/* put character in TX FIFO */
 372:calypso/uart.c **** 	writeb(c, UART_REG(uart, THR));
 622              		.loc 1 372 0 is_stmt 1
 623 0020 FF1001E2 		and	r1, r1, #255
 624              	.LVL41:
 625 0024 0010C3E5 		strb	r1, [r3, #0]
 373:calypso/uart.c **** }
 626              		.loc 1 373 0
 627 0028 1EFF2FE1 		bx	lr
 628              	.L57:
 629              		.align	2
 630              	.L56:
 631 002c EAFF1F00 		.word	2097130
 632              		.cfi_endproc
 633              	.LFE47:
 635              		.section	.text.uart_putchar_nb,"ax",%progbits
 636              		.align	2
 637              		.global	uart_putchar_nb
 639              	uart_putchar_nb:
 640              	.LFB48:
 374:calypso/uart.c **** 
 375:calypso/uart.c **** int uart_putchar_nb(uint8_t uart, int c)
 376:calypso/uart.c **** {
 641              		.loc 1 376 0
 642              		.cfi_startproc
 643              		@ args = 0, pretend = 0, frame = 0
 644              		@ frame_needed = 0, uses_anonymous_args = 0
 645              		@ link register save eliminated.
 646              	.LVL42:
 377:calypso/uart.c **** 	/* if TX FIFO indicates full, abort */
 378:calypso/uart.c **** 	if (readb(UART_REG(uart, SSR)) & 0x01)
 647              		.loc 1 378 0
 648 0000 24309FE5 		ldr	r3, .L61
 376:calypso/uart.c **** {
 649              		.loc 1 376 0
 650 0004 FF0000E2 		and	r0, r0, #255
 651              	.LVL43:
 652              		.loc 1 378 0
 653 0008 033080E0 		add	r3, r0, r3
 654 000c 8335A0E1 		mov	r3, r3, asl #11
 655 0010 1120D3E5 		ldrb	r2, [r3, #17]	@ zero_extendqisi2
 656 0014 010012E3 		tst	r2, #1
 379:calypso/uart.c **** 		return 0;
 380:calypso/uart.c **** 
 381:calypso/uart.c **** 	writeb(c, UART_REG(uart, THR));
 657              		.loc 1 381 0
 658 0018 FF100102 		andeq	r1, r1, #255
 659              	.LVL44:
 660 001c 0010C305 		streqb	r1, [r3, #0]
 382:calypso/uart.c **** 	return 1;
 661              		.loc 1 382 0
 662 0020 0100A003 		moveq	r0, #1
 379:calypso/uart.c **** 		return 0;
 663              		.loc 1 379 0
 664 0024 0000A013 		movne	r0, #0
 383:calypso/uart.c **** }
 665              		.loc 1 383 0
 666 0028 1EFF2FE1 		bx	lr
 667              	.L62:
 668              		.align	2
 669              	.L61:
 670 002c EAFF1F00 		.word	2097130
 671              		.cfi_endproc
 672              	.LFE48:
 674              		.section	.text.uart_getchar_nb,"ax",%progbits
 675              		.align	2
 676              		.global	uart_getchar_nb
 678              	uart_getchar_nb:
 679              	.LFB49:
 384:calypso/uart.c **** 
 385:calypso/uart.c **** int uart_getchar_nb(uint8_t uart, uint8_t *ch)
 386:calypso/uart.c **** {
 680              		.loc 1 386 0
 681              		.cfi_startproc
 682              		@ args = 0, pretend = 0, frame = 0
 683              		@ frame_needed = 0, uses_anonymous_args = 0
 684              	.LVL45:
 685 0000 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 686              	.LCFI5:
 687              		.cfi_def_cfa_offset 16
 387:calypso/uart.c **** 	uint8_t lsr;
 388:calypso/uart.c **** 
 389:calypso/uart.c **** 	lsr = readb(UART_REG(uart, LSR));
 688              		.loc 1 389 0
 689 0004 64509FE5 		ldr	r5, .L71
 690              		.cfi_offset 14, -4
 691              		.cfi_offset 6, -8
 692              		.cfi_offset 5, -12
 693              		.cfi_offset 4, -16
 386:calypso/uart.c **** {
 694              		.loc 1 386 0
 695 0008 FF0000E2 		and	r0, r0, #255
 696              	.LVL46:
 697              		.loc 1 389 0
 698 000c 055080E0 		add	r5, r0, r5
 699 0010 8555A0E1 		mov	r5, r5, asl #11
 700 0014 0530D5E5 		ldrb	r3, [r5, #5]	@ zero_extendqisi2
 390:calypso/uart.c **** 
 391:calypso/uart.c **** 	/* something strange happened */
 392:calypso/uart.c **** 	if (lsr & 0x02)
 701              		.loc 1 392 0
 702 0018 020013E3 		tst	r3, #2
 386:calypso/uart.c **** {
 703              		.loc 1 386 0
 704 001c 0160A0E1 		mov	r6, r1
 389:calypso/uart.c **** 	lsr = readb(UART_REG(uart, LSR));
 705              		.loc 1 389 0
 706 0020 FF4003E2 		and	r4, r3, #255
 707              	.LVL47:
 708              		.loc 1 392 0
 393:calypso/uart.c **** 		printf("LSR RX_OE\n");
 709              		.loc 1 393 0
 710 0024 48009F15 		ldrne	r0, .L71+4
 711 0028 FEFFFF1B 		blne	puts
 712              	.LVL48:
 713              	.L64:
 394:calypso/uart.c **** 	if (lsr & 0x04)
 714              		.loc 1 394 0
 715 002c 040014E3 		tst	r4, #4
 395:calypso/uart.c **** 		printf("LSR RX_PE\n");
 716              		.loc 1 395 0
 717 0030 40009F15 		ldrne	r0, .L71+8
 718 0034 FEFFFF1B 		blne	puts
 719              	.L65:
 396:calypso/uart.c **** 	if (lsr & 0x08)
 720              		.loc 1 396 0
 721 0038 080014E3 		tst	r4, #8
 397:calypso/uart.c **** 		printf("LSR RX_FE\n");
 722              		.loc 1 397 0
 723 003c 38009F15 		ldrne	r0, .L71+12
 724 0040 FEFFFF1B 		blne	puts
 725              	.L66:
 398:calypso/uart.c **** 	if (lsr & 0x10)
 726              		.loc 1 398 0
 727 0044 100014E3 		tst	r4, #16
 399:calypso/uart.c **** 		printf("LSR RX_BI\n");
 728              		.loc 1 399 0
 729 0048 30009F15 		ldrne	r0, .L71+16
 730 004c FEFFFF1B 		blne	puts
 731              	.L67:
 400:calypso/uart.c **** 	if (lsr & 0x80)
 732              		.loc 1 400 0
 733 0050 800014E3 		tst	r4, #128
 401:calypso/uart.c **** 		printf("LSR RX_FIFO_STS\n");
 734              		.loc 1 401 0
 735 0054 28009F15 		ldrne	r0, .L71+20
 736 0058 FEFFFF1B 		blne	puts
 737              	.L68:
 402:calypso/uart.c **** 
 403:calypso/uart.c **** 	/* is the Rx FIFO empty? */
 404:calypso/uart.c **** 	if (!(lsr & 0x01))
 738              		.loc 1 404 0
 739 005c 010014E2 		ands	r0, r4, #1
 405:calypso/uart.c **** 		return 0;
 406:calypso/uart.c **** 
 407:calypso/uart.c **** 	*ch = readb(UART_REG(uart, RHR));
 740              		.loc 1 407 0
 741 0060 0030D515 		ldrneb	r3, [r5, #0]	@ zero_extendqisi2
 408:calypso/uart.c **** 	//printf("getchar_nb(%u) = %02x\n", uart, *ch);
 409:calypso/uart.c **** 	return 1;
 742              		.loc 1 409 0
 743 0064 0100A013 		movne	r0, #1
 407:calypso/uart.c **** 	*ch = readb(UART_REG(uart, RHR));
 744              		.loc 1 407 0
 745 0068 0030C615 		strneb	r3, [r6, #0]
 410:calypso/uart.c **** }
 746              		.loc 1 410 0
 747 006c 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 748              	.L72:
 749              		.align	2
 750              	.L71:
 751 0070 EAFF1F00 		.word	2097130
 752 0074 00000000 		.word	.LC0
 753 0078 0A000000 		.word	.LC1
 754 007c 14000000 		.word	.LC2
 755 0080 1E000000 		.word	.LC3
 756 0084 28000000 		.word	.LC4
 757              		.cfi_endproc
 758              	.LFE49:
 760              		.section	.text.uart_tx_busy,"ax",%progbits
 761              		.align	2
 762              		.global	uart_tx_busy
 764              	uart_tx_busy:
 765              	.LFB50:
 411:calypso/uart.c **** 
 412:calypso/uart.c **** int uart_tx_busy(uint8_t uart)
 413:calypso/uart.c **** {
 766              		.loc 1 413 0
 767              		.cfi_startproc
 768              		@ args = 0, pretend = 0, frame = 0
 769              		@ frame_needed = 0, uses_anonymous_args = 0
 770              		@ link register save eliminated.
 771              	.LVL49:
 414:calypso/uart.c **** 	if (readb(UART_REG(uart, SSR)) & 0x01)
 772              		.loc 1 414 0
 773 0000 14309FE5 		ldr	r3, .L74
 413:calypso/uart.c **** {
 774              		.loc 1 413 0
 775 0004 FF0000E2 		and	r0, r0, #255
 776              	.LVL50:
 777              		.loc 1 414 0
 778 0008 033080E0 		add	r3, r0, r3
 779 000c 8335A0E1 		mov	r3, r3, asl #11
 780 0010 1100D3E5 		ldrb	r0, [r3, #17]	@ zero_extendqisi2
 415:calypso/uart.c **** 		return 1;
 416:calypso/uart.c **** 	return 0;
 417:calypso/uart.c **** }
 781              		.loc 1 417 0
 782 0014 010000E2 		and	r0, r0, #1
 783 0018 1EFF2FE1 		bx	lr
 784              	.L75:
 785              		.align	2
 786              	.L74:
 787 001c EAFF1F00 		.word	2097130
 788              		.cfi_endproc
 789              	.LFE50:
 791              		.section	.text.uart_irq_handler_sercomm,"ax",%progbits
 792              		.align	2
 794              	uart_irq_handler_sercomm:
 795              	.LFB43:
 228:calypso/uart.c **** {
 796              		.loc 1 228 0
 797              		.cfi_startproc
 798              		@ args = 0, pretend = 0, frame = 4
 799              		@ frame_needed = 0, uses_anonymous_args = 0
 800              	.LVL51:
 801 0000 31402DE9 		stmfd	sp!, {r0, r4, r5, lr}
 802              	.LCFI6:
 803              		.cfi_def_cfa_offset 16
 229:calypso/uart.c **** 	const uint8_t uart = sercomm_get_uart();
 804              		.loc 1 229 0
 805              		.cfi_offset 14, -4
 806              		.cfi_offset 5, -8
 807              		.cfi_offset 4, -12
 808              		.cfi_offset 0, -16
 809 0004 FEFFFFEB 		bl	sercomm_get_uart
 810              	.LVL52:
 234:calypso/uart.c **** 	iir = uart_reg_read(uart, IIR);
 811              		.loc 1 234 0
 812 0008 FF4000E2 		and	r4, r0, #255
 813 000c 0400A0E1 		mov	r0, r4
 814              	.LVL53:
 815 0010 0210A0E3 		mov	r1, #2
 816 0014 FEFFFFEB 		bl	uart_reg_read
 817              	.LVL54:
 235:calypso/uart.c **** 	if (iir & IIR_INT_PENDING)
 818              		.loc 1 235 0
 819 0018 010010E3 		tst	r0, #1
 820 001c 3C00001A 		bne	.L76
 238:calypso/uart.c **** 	switch (iir & IIR_INT_TYPE) {
 821              		.loc 1 238 0
 822 0020 3E0000E2 		and	r0, r0, #62
 823              	.LVL55:
 824 0024 100050E3 		cmp	r0, #16
 825 0028 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 826 002c 380000EA 		b	.L76
 827              	.L83:
 828 0030 FC000000 		.word	.L78
 829 0034 14010000 		.word	.L76
 830 0038 E4000000 		.word	.L79
 831 003c 14010000 		.word	.L76
 832 0040 98000000 		.word	.L89
 833 0044 14010000 		.word	.L76
 834 0048 04010000 		.word	.L81
 835 004c 14010000 		.word	.L76
 836 0050 14010000 		.word	.L76
 837 0054 14010000 		.word	.L76
 838 0058 14010000 		.word	.L76
 839 005c 14010000 		.word	.L76
 840 0060 98000000 		.word	.L89
 841 0064 14010000 		.word	.L76
 842 0068 14010000 		.word	.L76
 843 006c 14010000 		.word	.L76
 844 0070 0C010000 		.word	.L82
 845              	.LVL56:
 846              	.L85:
 243:calypso/uart.c **** 			if (sercomm_drv_rx_char(ch) < 0) {
 847              		.loc 1 243 0
 848 0074 0300DDE5 		ldrb	r0, [sp, #3]	@ zero_extendqisi2
 849 0078 FEFFFFEB 		bl	sercomm_drv_rx_char
 850 007c 000050E3 		cmp	r0, #0
 851 0080 050000AA 		bge	.L91
 245:calypso/uart.c **** 				uart_irq_enable(uart, UART_IRQ_RX_CHAR, 0);
 852              		.loc 1 245 0
 853 0084 0400A0E1 		mov	r0, r4
 854 0088 0110A0E3 		mov	r1, #1
 855 008c 0020A0E3 		mov	r2, #0
 856 0090 FEFFFFEB 		bl	uart_irq_enable
 857 0094 000000EA 		b	.L91
 858              	.LVL57:
 859              	.L89:
 242:calypso/uart.c **** 		while (uart_getchar_nb(uart, &ch)) {
 860              		.loc 1 242 0 discriminator 1
 861 0098 03508DE2 		add	r5, sp, #3
 862              	.LVL58:
 863              	.L91:
 864 009c 0400A0E1 		mov	r0, r4
 865 00a0 0510A0E1 		mov	r1, r5
 866 00a4 FEFFFFEB 		bl	uart_getchar_nb
 867 00a8 000050E3 		cmp	r0, #0
 868 00ac F0FFFF1A 		bne	.L85
 869 00b0 170000EA 		b	.L76
 870              	.L87:
 253:calypso/uart.c **** 			if (!sercomm_drv_pull(&ch)) {
 871              		.loc 1 253 0
 872 00b4 0500A0E1 		mov	r0, r5
 873 00b8 FEFFFFEB 		bl	sercomm_drv_pull
 874 00bc 001050E2 		subs	r1, r0, #0
 875 00c0 0300001A 		bne	.L86
 255:calypso/uart.c **** 				uart_irq_enable(uart, UART_IRQ_TX_EMPTY, 0);
 876              		.loc 1 255 0
 877 00c4 0400A0E1 		mov	r0, r4
 878 00c8 0120A0E1 		mov	r2, r1
 879 00cc FEFFFFEB 		bl	uart_irq_enable
 256:calypso/uart.c **** 				break;
 880              		.loc 1 256 0
 881 00d0 0F0000EA 		b	.L76
 882              	.L86:
 259:calypso/uart.c **** 			uart_putchar_nb(uart, ch);
 883              		.loc 1 259 0
 884 00d4 0400A0E1 		mov	r0, r4
 885 00d8 0310DDE5 		ldrb	r1, [sp, #3]	@ zero_extendqisi2
 886 00dc FEFFFFEB 		bl	uart_putchar_nb
 887 00e0 000000EA 		b	.L92
 888              	.LVL59:
 889              	.L79:
 253:calypso/uart.c **** 			if (!sercomm_drv_pull(&ch)) {
 890              		.loc 1 253 0 discriminator 1
 891 00e4 03508DE2 		add	r5, sp, #3
 892              	.LVL60:
 893              	.L92:
 251:calypso/uart.c **** 		while (!uart_tx_busy(uart)) {
 894              		.loc 1 251 0 discriminator 1
 895 00e8 0400A0E1 		mov	r0, r4
 896 00ec FEFFFFEB 		bl	uart_tx_busy
 897 00f0 000050E3 		cmp	r0, #0
 898 00f4 EEFFFF0A 		beq	.L87
 899 00f8 050000EA 		b	.L76
 900              	.LVL61:
 901              	.L78:
 263:calypso/uart.c **** 		printf("UART IRQ MSR\n");
 902              		.loc 1 263 0
 903 00fc 14009FE5 		ldr	r0, .L94
 904 0100 020000EA 		b	.L93
 905              	.L81:
 266:calypso/uart.c **** 		printf("UART IRQ RX_SE\n");
 906              		.loc 1 266 0
 907 0104 10009FE5 		ldr	r0, .L94+4
 908 0108 000000EA 		b	.L93
 909              	.L82:
 269:calypso/uart.c **** 		printf("UART IRQXOFF\n");
 910              		.loc 1 269 0
 911 010c 0C009FE5 		ldr	r0, .L94+8
 912              	.L93:
 913 0110 FEFFFFEB 		bl	puts
 914              	.LVL62:
 915              	.L76:
 272:calypso/uart.c **** }
 916              		.loc 1 272 0
 917 0114 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 918              	.L95:
 919              		.align	2
 920              	.L94:
 921 0118 38000000 		.word	.LC5
 922 011c 45000000 		.word	.LC6
 923 0120 54000000 		.word	.LC7
 924              		.cfi_endproc
 925              	.LFE43:
 927              		.section	.text.uart_poll,"ax",%progbits
 928              		.align	2
 929              		.global	uart_poll
 931              	uart_poll:
 932              	.LFB45:
 335:calypso/uart.c **** void uart_poll(uint8_t uart) {
 933              		.loc 1 335 0
 934              		.cfi_startproc
 935              		@ args = 0, pretend = 0, frame = 0
 936              		@ frame_needed = 0, uses_anonymous_args = 0
 937              	.LVL63:
 938 0000 10402DE9 		stmfd	sp!, {r4, lr}
 939              	.LCFI7:
 940              		.cfi_def_cfa_offset 8
 335:calypso/uart.c **** void uart_poll(uint8_t uart) {
 941              		.loc 1 335 0
 942 0004 FF4000E2 		and	r4, r0, #255
 943              		.cfi_offset 14, -4
 944              		.cfi_offset 4, -8
 336:calypso/uart.c **** 	if(uart == cons_get_uart()) {
 945              		.loc 1 336 0
 946 0008 FEFFFFEB 		bl	cons_get_uart
 947              	.LVL64:
 948 000c 000054E1 		cmp	r4, r0
 949 0010 0200001A 		bne	.L97
 337:calypso/uart.c **** 		uart_irq_handler_cons(0);
 950              		.loc 1 337 0
 951 0014 0000A0E3 		mov	r0, #0
 341:calypso/uart.c **** }
 952              		.loc 1 341 0
 953 0018 1040BDE8 		ldmfd	sp!, {r4, lr}
 337:calypso/uart.c **** 		uart_irq_handler_cons(0);
 954              		.loc 1 337 0
 955 001c FEFFFFEA 		b	uart_irq_handler_cons
 956              	.L97:
 339:calypso/uart.c **** 		uart_irq_handler_sercomm(0);
 957              		.loc 1 339 0
 958 0020 0000A0E3 		mov	r0, #0
 341:calypso/uart.c **** }
 959              		.loc 1 341 0
 960 0024 1040BDE8 		ldmfd	sp!, {r4, lr}
 339:calypso/uart.c **** 		uart_irq_handler_sercomm(0);
 961              		.loc 1 339 0
 962 0028 FEFFFFEA 		b	uart_irq_handler_sercomm
 963              		.cfi_endproc
 964              	.LFE45:
 966              		.section	.text.uart_baudrate,"ax",%progbits
 967              		.align	2
 968              		.global	uart_baudrate
 970              	uart_baudrate:
 971              	.LFB51:
 418:calypso/uart.c **** 
 419:calypso/uart.c **** static const uint16_t divider[] = {
 420:calypso/uart.c **** 	[UART_38400]	= 21,	/*   38,690 */
 421:calypso/uart.c **** 	[UART_57600]	= 14,	/*   58,035 */
 422:calypso/uart.c **** 	[UART_115200]	= 7,	/*  116,071 */
 423:calypso/uart.c **** 	[UART_230400]	= 4,	/*  203,125! (-3% would be 223,488) */
 424:calypso/uart.c **** 	[UART_460800]	= 2,	/*  406,250! (-3% would be 446,976) */
 425:calypso/uart.c **** 	[UART_921600]	= 1,	/*  812,500! (-3% would be 893,952) */
 426:calypso/uart.c **** };
 427:calypso/uart.c **** 
 428:calypso/uart.c **** int uart_baudrate(uint8_t uart, enum uart_baudrate bdrt)
 429:calypso/uart.c **** {
 972              		.loc 1 429 0
 973              		.cfi_startproc
 974              		@ args = 0, pretend = 0, frame = 0
 975              		@ frame_needed = 0, uses_anonymous_args = 0
 976              	.LVL65:
 430:calypso/uart.c **** 	uint16_t div;
 431:calypso/uart.c **** 
 432:calypso/uart.c **** 	if (bdrt >= ARRAY_SIZE(divider))
 977              		.loc 1 432 0
 978 0000 060051E3 		cmp	r1, #6
 429:calypso/uart.c **** {
 979              		.loc 1 429 0
 980 0004 30402DE9 		stmfd	sp!, {r4, r5, lr}
 981              	.LCFI8:
 982              		.cfi_def_cfa_offset 12
 429:calypso/uart.c **** {
 983              		.loc 1 429 0
 984 0008 FF4000E2 		and	r4, r0, #255
 985              		.cfi_offset 14, -4
 986              		.cfi_offset 5, -8
 987              		.cfi_offset 4, -12
 988              		.loc 1 432 0
 989 000c 1100008A 		bhi	.L100
 433:calypso/uart.c **** 		return -1;
 434:calypso/uart.c **** 
 435:calypso/uart.c **** 	div = divider[bdrt];
 990              		.loc 1 435 0
 991 0010 48309FE5 		ldr	r3, .L101
 992 0014 811083E0 		add	r1, r3, r1, asl #1
 993              	.LVL66:
 994 0018 B850D1E1 		ldrh	r5, [r1, #8]
 995              	.LVL67:
 436:calypso/uart.c **** 	uart_set_lcr7bit(uart, 1);
 996              		.loc 1 436 0
 997 001c 0400A0E1 		mov	r0, r4
 998              	.LVL68:
 999 0020 0110A0E3 		mov	r1, #1
 1000 0024 FEFFFFEB 		bl	uart_set_lcr7bit
 437:calypso/uart.c **** 	writeb(div & 0xff, UART_REG(uart, DLL));
 1001              		.loc 1 437 0
 1002 0028 34309FE5 		ldr	r3, .L101+4
 1003 002c 033084E0 		add	r3, r4, r3
 1004 0030 8335A0E1 		mov	r3, r3, asl #11
 1005 0034 FF2005E2 		and	r2, r5, #255
 438:calypso/uart.c **** 	writeb(div >> 8, UART_REG(uart, DLH));
 1006              		.loc 1 438 0
 1007 0038 2554A0E1 		mov	r5, r5, lsr #8
 1008              	.LVL69:
 437:calypso/uart.c **** 	writeb(div & 0xff, UART_REG(uart, DLL));
 1009              		.loc 1 437 0
 1010 003c 8020C3E5 		strb	r2, [r3, #128]
 439:calypso/uart.c **** 	uart_set_lcr7bit(uart, 0);
 1011              		.loc 1 439 0
 1012 0040 0400A0E1 		mov	r0, r4
 438:calypso/uart.c **** 	writeb(div >> 8, UART_REG(uart, DLH));
 1013              		.loc 1 438 0
 1014 0044 8150C3E5 		strb	r5, [r3, #129]
 1015              		.loc 1 439 0
 1016 0048 0010A0E3 		mov	r1, #0
 1017 004c FEFFFFEB 		bl	uart_set_lcr7bit
 440:calypso/uart.c **** 
 441:calypso/uart.c **** 	return 0;
 1018              		.loc 1 441 0
 1019 0050 0000A0E3 		mov	r0, #0
 1020 0054 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 1021              	.LVL70:
 1022              	.L100:
 433:calypso/uart.c **** 		return -1;
 1023              		.loc 1 433 0
 1024 0058 0000E0E3 		mvn	r0, #0
 1025              	.LVL71:
 442:calypso/uart.c **** }
 1026              		.loc 1 442 0
 1027 005c 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 1028              	.L102:
 1029              		.align	2
 1030              	.L101:
 1031 0060 00000000 		.word	.LANCHOR1
 1032 0064 EAFF1F00 		.word	2097130
 1033              		.cfi_endproc
 1034              	.LFE51:
 1036              		.section	.rodata
 1037              		.align	2
 1038              		.set	.LANCHOR1,. + 0
 1041              	CSWTCH.12:
 1042 0000 02       		.byte	2
 1043 0001 01       		.byte	1
 1044 0002 0000     		.space	2
 1047              	uart2irq:
 1048 0004 12       		.byte	18
 1049 0005 07       		.byte	7
 1050 0006 0000     		.space	2
 1053              	divider:
 1054 0008 1500     		.short	21
 1055 000a 0E00     		.short	14
 1056 000c 0700     		.short	7
 1057 000e 0400     		.short	4
 1058 0010 0200     		.short	2
 1059 0012 0000     		.space	2
 1060 0014 0100     		.short	1
 1061 0016 0000     		.section	.rodata.str1.1,"aMS",%progbits,1
 1062              	.LC0:
 1063 0000 4C535220 		.ascii	"LSR RX_OE\000"
 1063      52585F4F 
 1063      4500
 1064              	.LC1:
 1065 000a 4C535220 		.ascii	"LSR RX_PE\000"
 1065      52585F50 
 1065      4500
 1066              	.LC2:
 1067 0014 4C535220 		.ascii	"LSR RX_FE\000"
 1067      52585F46 
 1067      4500
 1068              	.LC3:
 1069 001e 4C535220 		.ascii	"LSR RX_BI\000"
 1069      52585F42 
 1069      4900
 1070              	.LC4:
 1071 0028 4C535220 		.ascii	"LSR RX_FIFO_STS\000"
 1071      52585F46 
 1071      49464F5F 
 1071      53545300 
 1072              	.LC5:
 1073 0038 55415254 		.ascii	"UART IRQ MSR\000"
 1073      20495251 
 1073      204D5352 
 1073      00
 1074              	.LC6:
 1075 0045 55415254 		.ascii	"UART IRQ RX_SE\000"
 1075      20495251 
 1075      2052585F 
 1075      534500
 1076              	.LC7:
 1077 0054 55415254 		.ascii	"UART IRQXOFF\000"
 1077      20495251 
 1077      584F4646 
 1077      00
 1078              		.bss
 1079              		.set	.LANCHOR0,. + 0
 1082              	old_lcr:
 1083 0000 00       		.space	1
 1084              		.text
 1085              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 uart.c
     /tmp/cc2LymJ3.s:12     .text.uart_set_lcr7bit:0000000000000000 $a
     /tmp/cc2LymJ3.s:14     .text.uart_set_lcr7bit:0000000000000000 uart_set_lcr7bit
     /tmp/cc2LymJ3.s:46     .text.uart_set_lcr7bit:0000000000000028 $d
     /tmp/cc2LymJ3.s:51     .text.uart_set_lcr_bf:0000000000000000 $a
     /tmp/cc2LymJ3.s:53     .text.uart_set_lcr_bf:0000000000000000 uart_set_lcr_bf
     /tmp/cc2LymJ3.s:84     .text.uart_set_lcr_bf:0000000000000030 $d
     /tmp/cc2LymJ3.s:90     .text.uart_set_mcr6bit:0000000000000000 $a
     /tmp/cc2LymJ3.s:92     .text.uart_set_mcr6bit:0000000000000000 uart_set_mcr6bit
     /tmp/cc2LymJ3.s:123    .text.uart_set_mcr6bit:0000000000000028 $d
     /tmp/cc2LymJ3.s:128    .text.uart_reg_write:0000000000000000 $a
     /tmp/cc2LymJ3.s:130    .text.uart_reg_write:0000000000000000 uart_reg_write
     /tmp/cc2LymJ3.s:220    .text.uart_reg_write:000000000000009c $d
     /tmp/cc2LymJ3.s:225    .text.uart_reg_read:0000000000000000 $a
     /tmp/cc2LymJ3.s:227    .text.uart_reg_read:0000000000000000 uart_reg_read
     /tmp/cc2LymJ3.s:310    .text.uart_reg_read:000000000000009c $d
     /tmp/cc2LymJ3.s:315    .text.uart_irq_handler_cons:0000000000000000 $a
     /tmp/cc2LymJ3.s:317    .text.uart_irq_handler_cons:0000000000000000 uart_irq_handler_cons
     /tmp/cc2LymJ3.s:375    .text.uart_irq_enable:0000000000000000 $a
     /tmp/cc2LymJ3.s:378    .text.uart_irq_enable:0000000000000000 uart_irq_enable
     /tmp/cc2LymJ3.s:429    .text.uart_irq_enable:000000000000004c $d
     /tmp/cc2LymJ3.s:434    .text.uart_init:0000000000000000 $a
     /tmp/cc2LymJ3.s:437    .text.uart_init:0000000000000000 uart_init
     /tmp/cc2LymJ3.s:590    .text.uart_init:000000000000017c $d
     /tmp/cc2LymJ3.s:794    .text.uart_irq_handler_sercomm:0000000000000000 uart_irq_handler_sercomm
     /tmp/cc2LymJ3.s:597    .text.uart_putchar_wait:0000000000000000 $a
     /tmp/cc2LymJ3.s:600    .text.uart_putchar_wait:0000000000000000 uart_putchar_wait
     /tmp/cc2LymJ3.s:631    .text.uart_putchar_wait:000000000000002c $d
     /tmp/cc2LymJ3.s:636    .text.uart_putchar_nb:0000000000000000 $a
     /tmp/cc2LymJ3.s:639    .text.uart_putchar_nb:0000000000000000 uart_putchar_nb
     /tmp/cc2LymJ3.s:670    .text.uart_putchar_nb:000000000000002c $d
     /tmp/cc2LymJ3.s:675    .text.uart_getchar_nb:0000000000000000 $a
     /tmp/cc2LymJ3.s:678    .text.uart_getchar_nb:0000000000000000 uart_getchar_nb
     /tmp/cc2LymJ3.s:751    .text.uart_getchar_nb:0000000000000070 $d
     /tmp/cc2LymJ3.s:761    .text.uart_tx_busy:0000000000000000 $a
     /tmp/cc2LymJ3.s:764    .text.uart_tx_busy:0000000000000000 uart_tx_busy
     /tmp/cc2LymJ3.s:787    .text.uart_tx_busy:000000000000001c $d
     /tmp/cc2LymJ3.s:792    .text.uart_irq_handler_sercomm:0000000000000000 $a
     /tmp/cc2LymJ3.s:828    .text.uart_irq_handler_sercomm:0000000000000030 $d
     /tmp/cc2LymJ3.s:848    .text.uart_irq_handler_sercomm:0000000000000074 $a
     /tmp/cc2LymJ3.s:921    .text.uart_irq_handler_sercomm:0000000000000118 $d
     /tmp/cc2LymJ3.s:928    .text.uart_poll:0000000000000000 $a
     /tmp/cc2LymJ3.s:931    .text.uart_poll:0000000000000000 uart_poll
     /tmp/cc2LymJ3.s:967    .text.uart_baudrate:0000000000000000 $a
     /tmp/cc2LymJ3.s:970    .text.uart_baudrate:0000000000000000 uart_baudrate
     /tmp/cc2LymJ3.s:1031   .text.uart_baudrate:0000000000000060 $d
     /tmp/cc2LymJ3.s:1037   .rodata:0000000000000000 $d
     /tmp/cc2LymJ3.s:1041   .rodata:0000000000000000 CSWTCH.12
     /tmp/cc2LymJ3.s:1047   .rodata:0000000000000004 uart2irq
     /tmp/cc2LymJ3.s:1053   .rodata:0000000000000008 divider
     /tmp/cc2LymJ3.s:1082   .bss:0000000000000000 old_lcr
     /tmp/cc2LymJ3.s:1083   .bss:0000000000000000 $d
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
cons_get_uart
cons_rb_flush
cons_init
irq_register_handler
irq_config
irq_enable
sercomm_get_uart
sercomm_init
puts
sercomm_drv_rx_char
sercomm_drv_pull
