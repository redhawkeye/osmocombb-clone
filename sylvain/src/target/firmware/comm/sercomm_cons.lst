   1              		.file	"sercomm_cons.c"
   9              	.Ltext0:
  10              		.cfi_sections	.debug_frame
  11              		.section	.text.raw_puts,"ax",%progbits
  12              		.align	2
  14              	raw_puts:
  15              	.LFB32:
  16              		.file 1 "comm/sercomm_cons.c"
   1:comm/sercomm_cons.c **** /* Serial console layer, layered on top of sercomm HDLC */
   2:comm/sercomm_cons.c **** 
   3:comm/sercomm_cons.c **** /* (C) 2010 by Harald Welte <laforge@gnumonks.org>
   4:comm/sercomm_cons.c ****  *
   5:comm/sercomm_cons.c ****  * All Rights Reserved
   6:comm/sercomm_cons.c ****  *
   7:comm/sercomm_cons.c ****  * This program is free software; you can redistribute it and/or modify
   8:comm/sercomm_cons.c ****  * it under the terms of the GNU General Public License as published by
   9:comm/sercomm_cons.c ****  * the Free Software Foundation; either version 2 of the License, or
  10:comm/sercomm_cons.c ****  * (at your option) any later version.
  11:comm/sercomm_cons.c ****  *
  12:comm/sercomm_cons.c ****  * This program is distributed in the hope that it will be useful,
  13:comm/sercomm_cons.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:comm/sercomm_cons.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:comm/sercomm_cons.c ****  * GNU General Public License for more details.
  16:comm/sercomm_cons.c ****  *
  17:comm/sercomm_cons.c ****  * You should have received a copy of the GNU General Public License along
  18:comm/sercomm_cons.c ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  19:comm/sercomm_cons.c ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  20:comm/sercomm_cons.c ****  *
  21:comm/sercomm_cons.c ****  */
  22:comm/sercomm_cons.c **** 
  23:comm/sercomm_cons.c **** #include <stdint.h>
  24:comm/sercomm_cons.c **** #include <errno.h>
  25:comm/sercomm_cons.c **** #include <string.h>
  26:comm/sercomm_cons.c **** 
  27:comm/sercomm_cons.c **** #include <asm/system.h>
  28:comm/sercomm_cons.c **** 
  29:comm/sercomm_cons.c **** #include <uart.h>
  30:comm/sercomm_cons.c **** 
  31:comm/sercomm_cons.c **** #include <console.h>
  32:comm/sercomm_cons.c **** #include <osmocom/core/msgb.h>
  33:comm/sercomm_cons.c **** #include <comm/sercomm.h>
  34:comm/sercomm_cons.c **** #include <comm/sercomm_cons.h>
  35:comm/sercomm_cons.c **** 
  36:comm/sercomm_cons.c **** static struct {
  37:comm/sercomm_cons.c **** 	struct msgb *cur_msg;
  38:comm/sercomm_cons.c **** } scons;
  39:comm/sercomm_cons.c **** 
  40:comm/sercomm_cons.c **** static void raw_puts(const char *s)
  41:comm/sercomm_cons.c **** {
  17              		.loc 1 41 0
  18              		.cfi_startproc
  19              		@ args = 0, pretend = 0, frame = 0
  20              		@ frame_needed = 0, uses_anonymous_args = 0
  21              	.LVL0:
  22 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
  23              	.LCFI0:
  24              		.cfi_def_cfa_offset 12
  25              		.loc 1 41 0
  26 0004 0050A0E1 		mov	r5, r0
  27              		.cfi_offset 14, -4
  28              		.cfi_offset 5, -8
  29              		.cfi_offset 4, -12
  42:comm/sercomm_cons.c **** 	int i = strlen(s);
  30              		.loc 1 42 0
  31 0008 FEFFFFEB 		bl	strlen
  32              	.LVL1:
  33 000c 0040A0E1 		mov	r4, r0
  43:comm/sercomm_cons.c **** 	while (i--)
  34              		.loc 1 43 0
  35 0010 030000EA 		b	.L2
  36              	.L3:
  44:comm/sercomm_cons.c **** 		uart_putchar_wait(SERCOMM_UART_NR, *s++);
  37              		.loc 1 44 0
  38 0014 0100A0E3 		mov	r0, #1
  39 0018 0110D5E4 		ldrb	r1, [r5], #1	@ zero_extendqisi2
  40              	.LVL2:
  41 001c FEFFFFEB 		bl	uart_putchar_wait
  42 0020 014044E2 		sub	r4, r4, #1
  43              	.LVL3:
  44              	.L2:
  43:comm/sercomm_cons.c **** 	while (i--)
  45              		.loc 1 43 0 discriminator 1
  46 0024 000054E3 		cmp	r4, #0
  47 0028 F9FFFF1A 		bne	.L3
  45:comm/sercomm_cons.c **** }
  48              		.loc 1 45 0
  49 002c 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
  50              		.cfi_endproc
  51              	.LFE32:
  53              		.section	.text.sercomm_puts,"ax",%progbits
  54              		.align	2
  55              		.global	sercomm_puts
  57              	sercomm_puts:
  58              	.LFB33:
  46:comm/sercomm_cons.c **** 
  47:comm/sercomm_cons.c **** #ifdef DEBUG
  48:comm/sercomm_cons.c **** #define raw_putd(x)	raw_puts(x)
  49:comm/sercomm_cons.c **** #else
  50:comm/sercomm_cons.c **** #define raw_putd(x)
  51:comm/sercomm_cons.c **** #endif
  52:comm/sercomm_cons.c **** 
  53:comm/sercomm_cons.c **** int sercomm_puts(const char *s)
  54:comm/sercomm_cons.c **** {
  59              		.loc 1 54 0
  60              		.cfi_startproc
  61              		@ args = 0, pretend = 0, frame = 4
  62              		@ frame_needed = 0, uses_anonymous_args = 0
  63              	.LVL4:
  64 0000 F14F2DE9 		stmfd	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  65              	.LCFI1:
  66              		.cfi_def_cfa_offset 40
  67              		.loc 1 54 0
  68 0004 0060A0E1 		mov	r6, r0
  69              		.cfi_offset 14, -4
  70              		.cfi_offset 11, -8
  71              		.cfi_offset 10, -12
  72              		.cfi_offset 9, -16
  73              		.cfi_offset 8, -20
  74              		.cfi_offset 7, -24
  75              		.cfi_offset 6, -28
  76              		.cfi_offset 5, -32
  77              		.cfi_offset 4, -36
  78              		.cfi_offset 0, -40
  55:comm/sercomm_cons.c **** 	unsigned long flags;
  56:comm/sercomm_cons.c **** 	const int len = strlen(s);
  79              		.loc 1 56 0
  80 0008 FEFFFFEB 		bl	strlen
  81              	.LVL5:
  82 000c 0090A0E1 		mov	r9, r0
  83              	.LVL6:
  57:comm/sercomm_cons.c **** 	unsigned int bytes_left = len;
  58:comm/sercomm_cons.c **** 
  59:comm/sercomm_cons.c **** 	if (!sercomm_initialized()) {
  84              		.loc 1 59 0
  85 0010 FEFFFFEB 		bl	sercomm_initialized
  86              	.LVL7:
  87 0014 000050E3 		cmp	r0, #0
  88 0018 0200001A 		bne	.L5
  60:comm/sercomm_cons.c **** 		raw_putd("sercomm not initialized: ");
  61:comm/sercomm_cons.c **** 		raw_puts(s);
  89              		.loc 1 61 0
  90 001c 0600A0E1 		mov	r0, r6
  91 0020 FEFFFFEB 		bl	raw_puts
  92 0024 4E0000EA 		b	.L23
  93              	.L5:
  94              	.LBB30:
  62:comm/sercomm_cons.c **** 		return len - 1;
  63:comm/sercomm_cons.c **** 	}
  64:comm/sercomm_cons.c **** 
  65:comm/sercomm_cons.c **** 	/* This function is called from any context: Supervisor, IRQ, FIQ, ...
  66:comm/sercomm_cons.c **** 	 * as such, we need to ensure re-entrant calls are either supported or
  67:comm/sercomm_cons.c **** 	 * avoided. */
  68:comm/sercomm_cons.c **** 	local_irq_save(flags);
  95              		.loc 1 68 0
  96              	@ 68 "comm/sercomm_cons.c" 1
  97 0028 00200FE1 		mrs	r2, cpsr		@ local_irq_save
  98 002c 803082E3 		orr	r3, r2, #128
  99 0030 03F021E1 		msr	cpsr_c, r3
 100              	@ 0 "" 2
 101 0034 00208DE5 		str	r2, [sp, #0]
 102              	.LVL8:
 103              	.LBE30:
 104              	.LBB31:
  69:comm/sercomm_cons.c **** 	local_fiq_disable();
 105              		.loc 1 69 0
 106              	@ 69 "comm/sercomm_cons.c" 1
 107 0038 00300FE1 		mrs	r3, cpsr		@ clf
 108 003c 403083E3 		orr	r3, r3, #64
 109 0040 03F021E1 		msr	cpsr_c, r3
 110              	@ 0 "" 2
 111              	.LBE31:
 112              	.LBB32:
  70:comm/sercomm_cons.c **** 
  71:comm/sercomm_cons.c **** 	while (bytes_left > 0) {
  72:comm/sercomm_cons.c **** 		unsigned int write_num, space_left, flush;
  73:comm/sercomm_cons.c **** 		uint8_t *data;
  74:comm/sercomm_cons.c **** 
  75:comm/sercomm_cons.c **** 		if (!scons.cur_msg)
 113              		.loc 1 75 0
 114 0044 20719FE5 		ldr	r7, .L24
 115              	.LBE32:
  57:comm/sercomm_cons.c **** 	unsigned int bytes_left = len;
 116              		.loc 1 57 0
 117 0048 0980A0E1 		mov	r8, r9
  71:comm/sercomm_cons.c **** 	while (bytes_left > 0) {
 118              		.loc 1 71 0
 119 004c 400000EA 		b	.L22
 120              	.LVL9:
 121              	.L17:
 122              	.LBB44:
 123              		.loc 1 75 0
 124 0050 003097E5 		ldr	r3, [r7, #0]
 125 0054 000053E3 		cmp	r3, #0
 126 0058 0B00001A 		bne	.L8
 127              	.LVL10:
 128              	.LBB33:
 129              	.LBB34:
 130              	.LBB35:
 131              		.file 2 "../../shared/libosmocore/include/osmocom/core/msgb.h"
   1:../../shared/libosmocore/include/osmocom/core/msgb.h **** #ifndef _MSGB_H
   2:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define _MSGB_H
   3:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
   4:../../shared/libosmocore/include/osmocom/core/msgb.h **** /* (C) 2008 by Harald Welte <laforge@gnumonks.org>
   5:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * All Rights Reserved
   6:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
   7:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This program is free software; you can redistribute it and/or modify
   8:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * it under the terms of the GNU General Public License as published by
   9:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * the Free Software Foundation; either version 2 of the License, or
  10:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * (at your option) any later version.
  11:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  12:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This program is distributed in the hope that it will be useful,
  13:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * GNU General Public License for more details.
  16:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  17:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * You should have received a copy of the GNU General Public License along
  18:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  19:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  20:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  21:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  22:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  23:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <stdint.h>
  24:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/linuxlist.h>
  25:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/utils.h>
  26:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  27:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \defgroup msgb Message buffers
  28:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  @{
  29:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  30:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  31:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \file msgb.h
  32:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \brief Osmocom message buffers
  33:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The Osmocom message buffers are modelled after the 'struct skb'
  34:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * inside the Linux kernel network stack.  As they exist in userspace,
  35:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * they are much simplified.  However, terminology such as headroom,
  36:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * tailroom, push/pull/put etc. remains the same.
  37:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  38:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  39:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_DEBUG
  40:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  41:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Osmocom message buffer */
  42:../../shared/libosmocore/include/osmocom/core/msgb.h **** struct msgb {
  43:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct llist_head list; /*!< \brief linked list header */
  44:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  45:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  46:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	/* Part of which TRX logical channel we were received / transmitted */
  47:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	/* FIXME: move them into the control buffer */
  48:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	union {
  49:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		void *dst; /*!< \brief reference of origin/destination */
  50:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		struct gsm_bts_trx *trx;
  51:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	};
  52:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct gsm_lchan *lchan; /*!< \brief logical channel */
  53:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  54:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l1h; /*!< \brief pointer to Layer1 header (if any) */
  55:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l2h; /*!< \brief pointer to A-bis layer 2 header: OML, RSL(RLL), NS */
  56:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l3h; /*!< \brief pointer to Layer 3 header. For OML: FOM; RSL: 04.08; GPRS: BSSGP *
  57:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l4h; /*!< \brief pointer to layer 4 header */
  58:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  59:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned long cb[5]; /*!< \brief control buffer */
  60:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  61:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint16_t data_len;   /*!< \brief length of underlying data array */
  62:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint16_t len;	     /*!< \brief length of bytes used in msgb */
  63:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  64:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *head;	/*!< \brief start of underlying memory buffer */
  65:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tail;	/*!< \brief end of message in buffer */
  66:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *data;	/*!< \brief start of message in buffer */
  67:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char _data[0]; /*!< \brief optional immediate data array */
  68:../../shared/libosmocore/include/osmocom/core/msgb.h **** };
  69:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  70:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern struct msgb *msgb_alloc(uint16_t size, const char *name);
  71:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_free(struct msgb *m);
  72:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_enqueue(struct llist_head *queue, struct msgb *msg);
  73:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern struct msgb *msgb_dequeue(struct llist_head *queue);
  74:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_reset(struct msgb *m);
  75:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  76:../../shared/libosmocore/include/osmocom/core/msgb.h **** #ifdef MSGB_DEBUG
  77:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/panic.h>
  78:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_ABORT(msg, fmt, args ...) do {		\
  79:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	osmo_panic("msgb(%p): " fmt, msg, ## args);	\
  80:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	} while(0)
  81:../../shared/libosmocore/include/osmocom/core/msgb.h **** #else
  82:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_ABORT(msg, fmt, args ...)
  83:../../shared/libosmocore/include/osmocom/core/msgb.h **** #endif
  84:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  85:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L1 header of msgb */
  86:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l1(m)	((void *)(m->l1h))
  87:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L2 header of msgb */
  88:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l2(m)	((void *)(m->l2h))
  89:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L3 header of msgb */
  90:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l3(m)	((void *)(m->l3h))
  91:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain SMS header of msgb */
  92:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_sms(m)	((void *)(m->l4h))
  93:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  94:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L1 message
  95:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
  96:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L1 message in bytes
  97:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  98:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
  99:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 1 header.
 100:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 101:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l1len(const struct msgb *msgb)
 102:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 103:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l1(msgb);
 104:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 105:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 106:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L2 message
 107:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 108:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L2 message in bytes
 109:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 110:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 111:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 2 header.
 112:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 113:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l2len(const struct msgb *msgb)
 114:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 115:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l2(msgb);
 116:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 117:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 118:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L3 message
 119:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 120:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L3 message in bytes
 121:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 122:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 123:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 3 header.
 124:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 125:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l3len(const struct msgb *msgb)
 126:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 127:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l3(msgb);
 128:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 129:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 130:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine the length of the header
 131:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 132:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes between start of buffer and start of msg
 133:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 134:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the length difference between the underlying
 135:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer and the used section of the \a msgb.
 136:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 137:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_headlen(const struct msgb *msgb)
 138:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 139:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->len - msgb->data_len;
 140:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 141:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 142:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine how much tail room is left in msgb
 143:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 144:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes remaining at end of msgb
 145:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 146:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the amount of octets left in the underlying
 147:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer after the end of the message.
 148:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 149:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_tailroom(const struct msgb *msgb)
 150:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 151:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->head + msgb->data_len) - msgb->tail;
 152:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 153:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 154:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine the amount of headroom in msgb
 155:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 156:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes left ahead of message start in msgb
 157:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 158:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the amount of bytes left in the underlying
 159:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer before the start of the actual message.
 160:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 161:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_headroom(const struct msgb *msgb)
 162:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 163:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->data - msgb->head);
 164:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 165:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 166:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append data to end of message buffer
 167:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 168:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of bytes to append to message
 169:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns pointer to start of newly-appended data
 170:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 171:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function will move the \a tail pointer of the message buffer \a
 172:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * len bytes further, thus enlarging the message by \a len bytes.
 173:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 174:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The return value is a pointer to start of the newly added section at
 175:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * the end of the message and can be used for actually filling/copying
 176:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data into it.
 177:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 178:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_put(struct msgb *msgb, unsigned int len)
 179:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 180:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tmp = msgb->tail;
 181:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_tailroom(msgb) < (int) len)
 182:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "Not enough tailroom msgb_push (%u < %u)\n",
 183:../../shared/libosmocore/include/osmocom/core/msgb.h **** 			   msgb_tailroom(msgb), len);
 184:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->tail += len;
 185:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len += len;
 186:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return tmp;
 187:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 188:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 189:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append a uint8 value to the end of the message
 190:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 191:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] word unsigned 8bit byte to be appended
 192:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 193:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline void msgb_put_u8(struct msgb *msgb, uint8_t word)
 194:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 195:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_put(msgb, 1);
 196:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[0] = word & 0xFF;
 197:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 198:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 199:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append a uint16 value to the end of the message
 200:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 201:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] word unsigned 16bit byte to be appended
 202:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 203:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline void msgb_put_u16(struct msgb *msgb, uint16_t word)
 204:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 205:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_put(msgb, 2);
 206:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[0] = word >> 8 & 0xFF;
 207:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[1] = word & 0xFF;
 208:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 209:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 210:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append a uint32 value to the end of the message
 211:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 212:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] word unsigned 32bit byte to be appended
 213:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 214:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline void msgb_put_u32(struct msgb *msgb, uint32_t word)
 215:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 216:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_put(msgb, 4);
 217:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[0] = word >> 24 & 0xFF;
 218:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[1] = word >> 16 & 0xFF;
 219:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[2] = word >> 8 & 0xFF;
 220:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[3] = word & 0xFF;
 221:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 222:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 223:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove data from end of message
 224:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 225:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of bytes to remove from end
 226:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 227:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_get(struct msgb *msgb, unsigned int len)
 228:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 229:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tmp = msgb->data;
 230:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->data += len;
 231:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len -= len;
 232:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return tmp;
 233:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 234:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint8 from end of message
 235:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 236:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 8bit value taken from end of msgb
 237:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 238:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint8_t msgb_get_u8(struct msgb *msgb)
 239:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 240:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_get(msgb, 1);
 241:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0];
 242:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 243:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint16 from end of message
 244:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 245:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 16bit value taken from end of msgb
 246:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 247:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint16_t msgb_get_u16(struct msgb *msgb)
 248:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 249:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_get(msgb, 2);
 250:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0] << 8 | space[1];
 251:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 252:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint32 from end of message
 253:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 254:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 32bit value taken from end of msgb
 255:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 256:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint32_t msgb_get_u32(struct msgb *msgb)
 257:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 258:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_get(msgb, 4);
 259:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0] << 24 | space[1] << 16 | space[2] << 8 | space[3];
 260:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 261:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 262:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief prepend (push) some data to start of message
 263:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 264:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of bytes to pre-pend
 265:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns pointer to newly added portion at start of \a msgb
 266:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 267:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function moves the \a data pointer of the \ref msgb further
 268:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * to the front (by \a len bytes), thereby enlarging the message by \a
 269:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * len bytes.
 270:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 271:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The return value is a pointer to the newly added section in the
 272:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * beginning of the message.  It can be used to fill/copy data into it.
 273:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 274:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_push(struct msgb *msgb, unsigned int len)
 275:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 276:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_headroom(msgb) < (int) len)
 277:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "Not enough headroom msgb_push (%u < %u)\n",
 278:../../shared/libosmocore/include/osmocom/core/msgb.h **** 			   msgb_headroom(msgb), len);
 279:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->data -= len;
 280:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len += len;
 281:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->data;
 282:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 283:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove (pull) a header from the front of the message buffer
 284:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 285:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of octets to be pulled
 286:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns pointer to new start of msgb
 287:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 288:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function moves the \a data pointer of the \ref msgb further back
 289:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * in the message, thereby shrinking the size of the message by \a len
 290:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * bytes.
 291:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 292:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_pull(struct msgb *msgb, unsigned int len)
 293:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 294:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len -= len;
 295:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->data += len;
 296:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 297:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 298:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Increase headroom of empty msgb, reducing the tailroom
 299:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msg message buffer
 300:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len amount of extra octets to be reserved as headroom
 301:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 302:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function reserves some memory at the beginning of the underlying
 303:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer.  The idea is to reserve space in case further headers
 304:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * have to be pushed to the \ref msgb during further processing.
 305:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 306:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * Calling this function leads to undefined reusults if it is called on
 307:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * a non-empty \ref msgb.
 308:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 309:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline void msgb_reserve(struct msgb *msg, int len)
 310:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 311:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->data += len;
 312:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->tail += len;
 313:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 314:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 315:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Allocate message buffer with specified headroom
 316:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] size size in bytes, including headroom
 317:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] headroom headroom in bytes
 318:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] name human-readable name
 319:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns allocated message buffer with specified headroom
 320:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 321:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function is a convenience wrapper around \ref msgb_alloc
 322:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * followed by \ref msgb_reserve in order to create a new \ref msgb with
 323:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * user-specified amount of headroom.
 324:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 325:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline struct msgb *msgb_alloc_headroom(int size, int headroom,
 326:../../shared/libosmocore/include/osmocom/core/msgb.h **** 						const char *name)
 327:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 328:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	osmo_static_assert(size > headroom, headroom_bigger);
 329:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 330:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct msgb *msg = msgb_alloc(size, name);
 132              		.loc 2 330 0
 133 005c 410FA0E3 		mov	r0, #260
 134 0060 08119FE5 		ldr	r1, .L24+4
 135 0064 FEFFFFEB 		bl	msgb_alloc
 136              	.LVL11:
 331:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msg)
 137              		.loc 2 331 0
 138 0068 000050E3 		cmp	r0, #0
 139 006c 0500000A 		beq	.L9
 140              	.LVL12:
 141              	.LBB36:
 142              	.LBB37:
 311:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->data += len;
 143              		.loc 2 311 0
 144 0070 403090E5 		ldr	r3, [r0, #64]
 145 0074 043083E2 		add	r3, r3, #4
 146 0078 403080E5 		str	r3, [r0, #64]
 312:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->tail += len;
 147              		.loc 2 312 0
 148 007c 3C3090E5 		ldr	r3, [r0, #60]
 149 0080 043083E2 		add	r3, r3, #4
 150 0084 3C3080E5 		str	r3, [r0, #60]
 151              	.LVL13:
 152              	.L9:
 153              	.LBE37:
 154              	.LBE36:
 155              	.LBE35:
 156              	.LBE34:
 157              	.LBE33:
  76:comm/sercomm_cons.c **** 			scons.cur_msg = sercomm_alloc_msgb(SERCOMM_CONS_ALLOC);
 158              		.loc 1 76 0
 159 0088 000087E5 		str	r0, [r7, #0]
 160              	.LVL14:
 161              	.L8:
  77:comm/sercomm_cons.c **** 
  78:comm/sercomm_cons.c **** 		if (!scons.cur_msg) {
 162              		.loc 1 78 0
 163 008c 004097E5 		ldr	r4, [r7, #0]
 164 0090 000054E3 		cmp	r4, #0
 165 0094 0300001A 		bne	.L10
  79:comm/sercomm_cons.c **** 			raw_putd("cannot allocate sercomm msgb: ");
  80:comm/sercomm_cons.c **** 			raw_puts(s);
 166              		.loc 1 80 0
 167 0098 0600A0E1 		mov	r0, r6
 168 009c FEFFFFEB 		bl	raw_puts
  81:comm/sercomm_cons.c **** 			return -ENOMEM;
 169              		.loc 1 81 0
 170 00a0 0B00E0E3 		mvn	r0, #11
 171 00a4 2F0000EA 		b	.L6
 172              	.L10:
 173              	.LVL15:
 174              	.LBB38:
 175              	.LBB39:
 151:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->head + msgb->data_len) - msgb->tail;
 176              		.loc 2 151 0
 177 00a8 B433D4E1 		ldrh	r3, [r4, #52]
 178 00ac 382084E2 		add	r2, r4, #56
 179 00b0 040892E8 		ldmia	r2, {r2, fp}	@ phole ldm
 180 00b4 032082E0 		add	r2, r2, r3
 181 00b8 02206BE0 		rsb	r2, fp, r2
 182              	.LVL16:
 183              	.LBE39:
 184              	.LBE38:
  82:comm/sercomm_cons.c **** 		}
  83:comm/sercomm_cons.c **** 
  84:comm/sercomm_cons.c **** 		/* space left in the current msgb */
  85:comm/sercomm_cons.c **** 		space_left = msgb_tailroom(scons.cur_msg);
  86:comm/sercomm_cons.c **** 
  87:comm/sercomm_cons.c **** 		if (space_left <= bytes_left) {
 185              		.loc 1 87 0
 186 00bc 080052E1 		cmp	r2, r8
 187 00c0 0250A091 		movls	r5, r2
 188 00c4 0850A081 		movhi	r5, r8
  88:comm/sercomm_cons.c **** 			write_num = space_left;
  89:comm/sercomm_cons.c **** 			/* flush buffer when it is full */
  90:comm/sercomm_cons.c **** 			flush = 1;
 189              		.loc 1 90 0
 190 00c8 01A0A093 		movls	sl, #1
  91:comm/sercomm_cons.c **** 		} else {
  92:comm/sercomm_cons.c **** 			write_num = bytes_left;
  93:comm/sercomm_cons.c **** 			flush = 0;
 191              		.loc 1 93 0
 192 00cc 00A0A083 		movhi	sl, #0
 193              	.LVL17:
 194              	.LBB40:
 195              	.LBB41:
 181:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_tailroom(msgb) < (int) len)
 196              		.loc 2 181 0
 197 00d0 050052E1 		cmp	r2, r5
 198              	.LVL18:
 182:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "Not enough tailroom msgb_push (%u < %u)\n",
 199              		.loc 2 182 0
 200 00d4 98009FB5 		ldrlt	r0, .L24+8
 201 00d8 0410A0B1 		movlt	r1, r4
 202 00dc 0530A0B1 		movlt	r3, r5
 203 00e0 FEFFFFBB 		bllt	osmo_panic
 204              	.LVL19:
 205              	.L12:
 184:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->tail += len;
 206              		.loc 2 184 0
 207 00e4 3C3094E5 		ldr	r3, [r4, #60]
 208 00e8 053083E0 		add	r3, r3, r5
 209 00ec 3C3084E5 		str	r3, [r4, #60]
 185:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len += len;
 210              		.loc 2 185 0
 211 00f0 B633D4E1 		ldrh	r3, [r4, #54]
 212 00f4 033085E0 		add	r3, r5, r3
 213 00f8 B633C4E1 		strh	r3, [r4, #54]	@ movhi
 214              	.LVL20:
 215              	.LBE41:
 216              	.LBE40:
 217              	.LBB42:
  94:comm/sercomm_cons.c **** 		}
  95:comm/sercomm_cons.c **** 
  96:comm/sercomm_cons.c **** 		/* obtain pointer where to copy the data */
  97:comm/sercomm_cons.c **** 		data = msgb_put(scons.cur_msg, write_num);
  98:comm/sercomm_cons.c **** 
  99:comm/sercomm_cons.c **** 		/* copy data while looking for \n line termination */
 100:comm/sercomm_cons.c **** 		{
 101:comm/sercomm_cons.c **** 			unsigned int i;
 102:comm/sercomm_cons.c **** 			for (i = 0; i < write_num; i++) {
 218              		.loc 1 102 0
 219 00fc 0040A0E3 		mov	r4, #0
 220              	.LVL21:
 221 0100 080000EA 		b	.L13
 222              	.LVL22:
 223              	.L15:
 103:comm/sercomm_cons.c **** 				/* flush buffer at end of line, but skip
 104:comm/sercomm_cons.c **** 				 * flushing if we have a backlog in order to
 105:comm/sercomm_cons.c **** 				 * increase efficiency of msgb filling */
 106:comm/sercomm_cons.c **** 				if (*s == '\n' &&
 224              		.loc 1 106 0
 225 0104 0400D6E7 		ldrb	r0, [r6, r4]	@ zero_extendqisi2
 226 0108 0A0050E3 		cmp	r0, #10
 227 010c 0200001A 		bne	.L14
 107:comm/sercomm_cons.c **** 				    sercomm_tx_queue_depth(SC_DLCI_CONSOLE) < 4)
 228              		.loc 1 107 0 discriminator 1
 229 0110 FEFFFFEB 		bl	sercomm_tx_queue_depth
 108:comm/sercomm_cons.c **** 					flush = 1;
 230              		.loc 1 108 0 discriminator 1
 231 0114 030050E3 		cmp	r0, #3
 232 0118 01A0A093 		movls	sl, #1
 233              	.LVL23:
 234              	.L14:
 109:comm/sercomm_cons.c **** 				*data++ = *s++;
 235              		.loc 1 109 0
 236 011c 0430D6E7 		ldrb	r3, [r6, r4]	@ zero_extendqisi2
 237 0120 0430CBE7 		strb	r3, [fp, r4]
 102:comm/sercomm_cons.c **** 			for (i = 0; i < write_num; i++) {
 238              		.loc 1 102 0
 239 0124 014084E2 		add	r4, r4, #1
 240              	.LVL24:
 241              	.L13:
 102:comm/sercomm_cons.c **** 			for (i = 0; i < write_num; i++) {
 242              		.loc 1 102 0 is_stmt 0 discriminator 1
 243 0128 050054E1 		cmp	r4, r5
 244 012c F4FFFF3A 		bcc	.L15
 245              	.LBE42:
 110:comm/sercomm_cons.c **** 			}
 111:comm/sercomm_cons.c **** 		}
 112:comm/sercomm_cons.c **** 		bytes_left -= write_num;
 113:comm/sercomm_cons.c **** 
 114:comm/sercomm_cons.c **** 		if (flush) {
 246              		.loc 1 114 0 is_stmt 1
 247 0130 00005AE3 		cmp	sl, #0
 248              	.LBB43:
 102:comm/sercomm_cons.c **** 			for (i = 0; i < write_num; i++) {
 249              		.loc 1 102 0
 250 0134 056086E0 		add	r6, r6, r5
 251              	.LBE43:
 112:comm/sercomm_cons.c **** 		bytes_left -= write_num;
 252              		.loc 1 112 0
 253 0138 088065E0 		rsb	r8, r5, r8
 254              	.LVL25:
 255              		.loc 1 114 0
 256 013c 0400000A 		beq	.L22
 115:comm/sercomm_cons.c **** 			sercomm_sendmsg(SC_DLCI_CONSOLE, scons.cur_msg);
 257              		.loc 1 115 0
 258 0140 0A00A0E3 		mov	r0, #10
 259 0144 001097E5 		ldr	r1, [r7, #0]
 260 0148 FEFFFFEB 		bl	sercomm_sendmsg
 116:comm/sercomm_cons.c **** 			/* reset scons.cur_msg pointer to ensure we allocate
 117:comm/sercomm_cons.c **** 			 * a new one next round */
 118:comm/sercomm_cons.c **** 			scons.cur_msg = NULL;
 261              		.loc 1 118 0
 262 014c 0030A0E3 		mov	r3, #0
 263 0150 003087E5 		str	r3, [r7, #0]
 264              	.LVL26:
 265              	.L22:
 266              	.LBE44:
  71:comm/sercomm_cons.c **** 	while (bytes_left > 0) {
 267              		.loc 1 71 0 discriminator 1
 268 0154 000058E3 		cmp	r8, #0
 269 0158 BCFFFF1A 		bne	.L17
 119:comm/sercomm_cons.c **** 		}
 120:comm/sercomm_cons.c **** 	}
 121:comm/sercomm_cons.c **** 
 122:comm/sercomm_cons.c **** 	local_irq_restore(flags);
 270              		.loc 1 122 0
 271 015c 00209DE5 		ldr	r2, [sp, #0]
 272              	@ 122 "comm/sercomm_cons.c" 1
 273 0160 02F021E1 		msr	cpsr_c, r2		@ local_irq_restore
 274              	
 275              	@ 0 "" 2
 276              	.LVL27:
 277              	.L23:
 123:comm/sercomm_cons.c **** 
 124:comm/sercomm_cons.c **** 	return len - 1;
 278              		.loc 1 124 0
 279 0164 010049E2 		sub	r0, r9, #1
 280              	.L6:
 125:comm/sercomm_cons.c **** }
 281              		.loc 1 125 0
 282 0168 F88FBDE8 		ldmfd	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 283              	.L25:
 284              		.align	2
 285              	.L24:
 286 016c 00000000 		.word	.LANCHOR0
 287 0170 00000000 		.word	.LC0
 288 0174 0B000000 		.word	.LC1
 289              		.cfi_endproc
 290              	.LFE33:
 292              		.section	.text.sercomm_putchar,"ax",%progbits
 293              		.align	2
 294              		.global	sercomm_putchar
 296              	sercomm_putchar:
 297              	.LFB34:
 126:comm/sercomm_cons.c **** 
 127:comm/sercomm_cons.c **** int sercomm_putchar(int c)
 128:comm/sercomm_cons.c **** {
 298              		.loc 1 128 0
 299              		.cfi_startproc
 300              		@ args = 0, pretend = 0, frame = 4
 301              		@ frame_needed = 0, uses_anonymous_args = 0
 302              	.LVL28:
 303 0000 11402DE9 		stmfd	sp!, {r0, r4, lr}
 304              	.LCFI2:
 305              		.cfi_def_cfa_offset 12
 129:comm/sercomm_cons.c **** 	char s[2];
 130:comm/sercomm_cons.c **** 	int rc;
 131:comm/sercomm_cons.c **** 
 132:comm/sercomm_cons.c **** 	s[0] = c & 0xff;
 133:comm/sercomm_cons.c **** 	s[1] = '\0';
 306              		.loc 1 133 0
 307 0004 0030A0E3 		mov	r3, #0
 128:comm/sercomm_cons.c **** {
 308              		.loc 1 128 0
 309 0008 0040A0E1 		mov	r4, r0
 310              		.cfi_offset 14, -4
 311              		.cfi_offset 4, -8
 312              		.cfi_offset 0, -12
 132:comm/sercomm_cons.c **** 	s[0] = c & 0xff;
 313              		.loc 1 132 0
 314 000c 0000CDE5 		strb	r0, [sp, #0]
 134:comm/sercomm_cons.c **** 
 135:comm/sercomm_cons.c **** 	rc = sercomm_puts(s);
 315              		.loc 1 135 0
 316 0010 0D00A0E1 		mov	r0, sp
 317              	.LVL29:
 133:comm/sercomm_cons.c **** 	s[1] = '\0';
 318              		.loc 1 133 0
 319 0014 0130CDE5 		strb	r3, [sp, #1]
 320              		.loc 1 135 0
 321 0018 FEFFFFEB 		bl	sercomm_puts
 322              	.LVL30:
 136:comm/sercomm_cons.c **** 	if (rc < 0)
 137:comm/sercomm_cons.c **** 		return rc;
 138:comm/sercomm_cons.c **** 
 139:comm/sercomm_cons.c **** 	return c;
 140:comm/sercomm_cons.c **** }
 323              		.loc 1 140 0
 324 001c 000050E3 		cmp	r0, #0
 325 0020 0400A0A1 		movge	r0, r4
 326              	.LVL31:
 327 0024 1880BDE8 		ldmfd	sp!, {r3, r4, pc}
 328              		.cfi_endproc
 329              	.LFE34:
 331              		.section	.rodata.str1.1,"aMS",%progbits,1
 332              	.LC0:
 333 0000 73657263 		.ascii	"sercomm_tx\000"
 333      6F6D6D5F 
 333      747800
 334              	.LC1:
 335 000b 6D736762 		.ascii	"msgb(%p): Not enough tailroom msgb_push (%u < %u)\012"
 335      28257029 
 335      3A204E6F 
 335      7420656E 
 335      6F756768 
 336 003d 00       		.ascii	"\000"
 337              		.bss
 338              		.align	2
 339              		.set	.LANCHOR0,. + 0
 342              	scons:
 343 0000 00000000 		.space	4
 344              		.text
 345              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 sercomm_cons.c
     /tmp/ccjdbzKR.s:12     .text.raw_puts:0000000000000000 $a
     /tmp/ccjdbzKR.s:14     .text.raw_puts:0000000000000000 raw_puts
     /tmp/ccjdbzKR.s:54     .text.sercomm_puts:0000000000000000 $a
     /tmp/ccjdbzKR.s:57     .text.sercomm_puts:0000000000000000 sercomm_puts
     /tmp/ccjdbzKR.s:286    .text.sercomm_puts:000000000000016c $d
     /tmp/ccjdbzKR.s:293    .text.sercomm_putchar:0000000000000000 $a
     /tmp/ccjdbzKR.s:296    .text.sercomm_putchar:0000000000000000 sercomm_putchar
     /tmp/ccjdbzKR.s:338    .bss:0000000000000000 $d
     /tmp/ccjdbzKR.s:342    .bss:0000000000000000 scons
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
strlen
uart_putchar_wait
sercomm_initialized
msgb_alloc
osmo_panic
sercomm_tx_queue_depth
sercomm_sendmsg
