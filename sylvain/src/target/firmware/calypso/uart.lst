   1              		.file	"uart.c"
   9              	.Ltext0:
  10              		.cfi_sections	.debug_frame
  11              		.section	.text.uart_set_lcr7bit,"ax",%progbits
  12              		.align	2
  14              	uart_set_lcr7bit:
  15              	.LFB32:
  16              		.file 1 "calypso/uart.c"
   1:calypso/uart.c **** /* Calypso DBB internal UART Driver */
   2:calypso/uart.c **** 
   3:calypso/uart.c **** /* (C) 2010 by Harald Welte <laforge@gnumonks.org>
   4:calypso/uart.c ****  * (C) 2010 by Ingo Albrecht <prom@berlin.ccc.de>
   5:calypso/uart.c ****  *
   6:calypso/uart.c ****  * All Rights Reserved
   7:calypso/uart.c ****  *
   8:calypso/uart.c ****  * This program is free software; you can redistribute it and/or modify
   9:calypso/uart.c ****  * it under the terms of the GNU General Public License as published by
  10:calypso/uart.c ****  * the Free Software Foundation; either version 2 of the License, or
  11:calypso/uart.c ****  * (at your option) any later version.
  12:calypso/uart.c ****  *
  13:calypso/uart.c ****  * This program is distributed in the hope that it will be useful,
  14:calypso/uart.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15:calypso/uart.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  16:calypso/uart.c ****  * GNU General Public License for more details.
  17:calypso/uart.c ****  *
  18:calypso/uart.c ****  * You should have received a copy of the GNU General Public License along
  19:calypso/uart.c ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  20:calypso/uart.c ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  21:calypso/uart.c ****  *
  22:calypso/uart.c ****  */
  23:calypso/uart.c **** 
  24:calypso/uart.c **** #include <debug.h>
  25:calypso/uart.c **** 
  26:calypso/uart.c **** #include <memory.h>
  27:calypso/uart.c **** #include <stdint.h>
  28:calypso/uart.c **** #include <string.h>
  29:calypso/uart.c **** #include <stdio.h>
  30:calypso/uart.c **** 
  31:calypso/uart.c **** #include <defines.h>
  32:calypso/uart.c **** #include <console.h>
  33:calypso/uart.c **** #include <comm/sercomm.h>
  34:calypso/uart.c **** 
  35:calypso/uart.c **** #include <calypso/irq.h>
  36:calypso/uart.c **** #include <uart.h>
  37:calypso/uart.c **** 
  38:calypso/uart.c **** #define BASE_ADDR_UART_MODEM	0xffff5000
  39:calypso/uart.c **** #define OFFSET_IRDA		0x800
  40:calypso/uart.c **** 
  41:calypso/uart.c **** #define UART_REG(n,m)	(BASE_ADDR_UART_MODEM + ((n)*OFFSET_IRDA)+(m))
  42:calypso/uart.c **** 
  43:calypso/uart.c **** #define LCR7BIT		0x80
  44:calypso/uart.c **** #define LCRBFBIT	0x40
  45:calypso/uart.c **** #define MCR6BIT		0x20
  46:calypso/uart.c **** #define REG_OFFS(m)	((m) & ~(LCR7BIT|LCRBFBIT|MCR6BIT))
  47:calypso/uart.c **** /* read access LCR[7] = 0 */
  48:calypso/uart.c **** enum uart_reg {
  49:calypso/uart.c **** 	RHR	= 0,
  50:calypso/uart.c **** 	IER	= 1,
  51:calypso/uart.c **** 	IIR	= 2,
  52:calypso/uart.c **** 	LCR	= 3,
  53:calypso/uart.c **** 	MCR	= 4,
  54:calypso/uart.c **** 	LSR	= 5,
  55:calypso/uart.c **** 	MSR	= 6,
  56:calypso/uart.c **** 	SPR	= 7,
  57:calypso/uart.c **** 	MDR1	= 8,
  58:calypso/uart.c **** 	DMR2	= 9,
  59:calypso/uart.c **** 	SFLSR	= 0x0a,
  60:calypso/uart.c **** 	RESUME	= 0x0b,
  61:calypso/uart.c **** 	SFREGL	= 0x0c,
  62:calypso/uart.c **** 	SFREGH	= 0x0d,
  63:calypso/uart.c **** 	BLR	= 0x0e,
  64:calypso/uart.c **** 	ACREG	= 0x0f,
  65:calypso/uart.c **** 	SCR	= 0x10,
  66:calypso/uart.c **** 	SSR	= 0x11,
  67:calypso/uart.c **** 	EBLR	= 0x12,
  68:calypso/uart.c **** /* read access LCR[7] = 1 */
  69:calypso/uart.c **** 	DLL	= RHR | LCR7BIT,
  70:calypso/uart.c **** 	DLH	= IER | LCR7BIT,
  71:calypso/uart.c **** 	DIV1_6	= ACREG | LCR7BIT,
  72:calypso/uart.c **** /* read/write access LCR[7:0] = 0xbf */
  73:calypso/uart.c **** 	EFR	= IIR | LCRBFBIT,
  74:calypso/uart.c **** 	XON1	= MCR | LCRBFBIT,
  75:calypso/uart.c **** 	XON2	= LSR | LCRBFBIT,
  76:calypso/uart.c **** 	XOFF1	= MSR | LCRBFBIT,
  77:calypso/uart.c **** 	XOFF2 	= SPR | LCRBFBIT,
  78:calypso/uart.c **** /* read/write access if EFR[4] = 1 and MCR[6] = 1 */
  79:calypso/uart.c **** 	TCR	= MSR | MCR6BIT,
  80:calypso/uart.c **** 	TLR	= SPR | MCR6BIT,
  81:calypso/uart.c **** };
  82:calypso/uart.c **** /* write access LCR[7] = 0 */
  83:calypso/uart.c **** #define THR	RHR
  84:calypso/uart.c **** #define FCR	IIR		/* only if EFR[4] = 1 */
  85:calypso/uart.c **** #define TXFLL	SFLSR
  86:calypso/uart.c **** #define TXFLH	RESUME
  87:calypso/uart.c **** #define RXFLL	SFREGL
  88:calypso/uart.c **** #define RXFLH	SFREGH
  89:calypso/uart.c **** 
  90:calypso/uart.c **** enum fcr_bits {
  91:calypso/uart.c **** 	FIFO_EN		= (1 << 0),
  92:calypso/uart.c **** 	RX_FIFO_CLEAR	= (1 << 1),
  93:calypso/uart.c **** 	TX_FIFO_CLEAR	= (1 << 2),
  94:calypso/uart.c **** 	DMA_MODE	= (1 << 3),
  95:calypso/uart.c **** };
  96:calypso/uart.c **** #define TX_FIFO_TRIG_SHIFT	4
  97:calypso/uart.c **** #define RX_FIFO_TRIG_SHIFT	6
  98:calypso/uart.c **** 
  99:calypso/uart.c **** enum iir_bits {
 100:calypso/uart.c **** 	IIR_INT_PENDING			= 0x01,
 101:calypso/uart.c **** 	IIR_INT_TYPE			= 0x3E,
 102:calypso/uart.c **** 	IIR_INT_TYPE_RX_STATUS_ERROR 	= 0x06,
 103:calypso/uart.c **** 	IIR_INT_TYPE_RX_TIMEOUT		= 0x0C,
 104:calypso/uart.c **** 	IIR_INT_TYPE_RHR		= 0x04,
 105:calypso/uart.c **** 	IIR_INT_TYPE_THR		= 0x02,
 106:calypso/uart.c **** 	IIR_INT_TYPE_MSR		= 0x00,
 107:calypso/uart.c **** 	IIR_INT_TYPE_XOFF		= 0x10,
 108:calypso/uart.c **** 	IIR_INT_TYPE_FLOW		= 0x20,
 109:calypso/uart.c **** 	IIR_FCR0_MIRROR			= 0xC0,
 110:calypso/uart.c **** };
 111:calypso/uart.c **** 
 112:calypso/uart.c **** #define UART_REG_UIR	0xffff6000
 113:calypso/uart.c **** 
 114:calypso/uart.c **** /* enable or disable the divisor latch for access to DLL, DLH */
 115:calypso/uart.c **** static void uart_set_lcr7bit(int uart, int on)
 116:calypso/uart.c **** {
  17              		.loc 1 116 0
  18              		.cfi_startproc
  19              		@ args = 0, pretend = 0, frame = 0
  20              		@ frame_needed = 0, uses_anonymous_args = 0
  21              		@ link register save eliminated.
  22              	.LVL0:
 117:calypso/uart.c **** 	uint8_t reg;
 118:calypso/uart.c **** 
 119:calypso/uart.c **** 	reg = readb(UART_REG(uart, LCR));
  23              		.loc 1 119 0
  24 0000 20309FE5 		ldr	r3, .L4
  25 0004 033080E0 		add	r3, r0, r3
  26 0008 8335A0E1 		mov	r3, r3, asl #11
  27 000c 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 120:calypso/uart.c **** 	if (on)
  28              		.loc 1 120 0
  29 0010 000051E3 		cmp	r1, #0
 119:calypso/uart.c **** 	reg = readb(UART_REG(uart, LCR));
  30              		.loc 1 119 0
  31 0014 FF0002E2 		and	r0, r2, #255
  32              	.LVL1:
 121:calypso/uart.c **** 		reg |= (1 << 7);
  33              		.loc 1 121 0
  34 0018 80208013 		orrne	r2, r0, #128
  35              	.LVL2:
 122:calypso/uart.c **** 	else
 123:calypso/uart.c **** 		reg &= ~(1 << 7);
  36              		.loc 1 123 0
  37 001c 7F200202 		andeq	r2, r2, #127
  38              	.LVL3:
 124:calypso/uart.c **** 	writeb(reg, UART_REG(uart, LCR));
  39              		.loc 1 124 0
  40 0020 0320C3E5 		strb	r2, [r3, #3]
 125:calypso/uart.c **** }
  41              		.loc 1 125 0
  42 0024 1EFF2FE1 		bx	lr
  43              	.L5:
  44              		.align	2
  45              	.L4:
  46 0028 EAFF1F00 		.word	2097130
  47              		.cfi_endproc
  48              	.LFE32:
  50              		.section	.text.uart_set_lcr_bf,"ax",%progbits
  51              		.align	2
  53              	uart_set_lcr_bf:
  54              	.LFB33:
 126:calypso/uart.c **** 
 127:calypso/uart.c **** static uint8_t old_lcr;
 128:calypso/uart.c **** static void uart_set_lcr_bf(int uart, int on)
 129:calypso/uart.c **** {
  55              		.loc 1 129 0
  56              		.cfi_startproc
  57              		@ args = 0, pretend = 0, frame = 0
  58              		@ frame_needed = 0, uses_anonymous_args = 0
  59              		@ link register save eliminated.
  60              	.LVL4:
  61 0000 28309FE5 		ldr	r3, .L10
 130:calypso/uart.c **** 	if (on) {
  62              		.loc 1 130 0
  63 0004 000051E3 		cmp	r1, #0
  64 0008 033080E0 		add	r3, r0, r3
  65 000c 20209FE5 		ldr	r2, .L10+4
 131:calypso/uart.c **** 		old_lcr = readb(UART_REG(uart, LCR));
  66              		.loc 1 131 0
  67 0010 8335A011 		movne	r3, r3, asl #11
  68 0014 0310D315 		ldrneb	r1, [r3, #3]	@ zero_extendqisi2
  69              	.LVL5:
 132:calypso/uart.c **** 		writeb(0xBF, UART_REG(uart, LCR));
 133:calypso/uart.c **** 	} else {
 134:calypso/uart.c **** 		writeb(old_lcr, UART_REG(uart, LCR));
  70              		.loc 1 134 0
  71 0018 0020D205 		ldreqb	r2, [r2, #0]	@ zero_extendqisi2
 131:calypso/uart.c **** 		old_lcr = readb(UART_REG(uart, LCR));
  72              		.loc 1 131 0
  73 001c 0010C215 		strneb	r1, [r2, #0]
  74              		.loc 1 134 0
  75 0020 8335A001 		moveq	r3, r3, asl #11
 132:calypso/uart.c **** 		writeb(0xBF, UART_REG(uart, LCR));
  76              		.loc 1 132 0
  77 0024 4020E013 		mvnne	r2, #64
  78              		.loc 1 134 0
  79 0028 0320C3E5 		strb	r2, [r3, #3]
  80 002c 1EFF2FE1 		bx	lr
  81              	.L11:
  82              		.align	2
  83              	.L10:
  84 0030 EAFF1F00 		.word	2097130
  85 0034 00000000 		.word	.LANCHOR0
  86              		.cfi_endproc
  87              	.LFE33:
  89              		.section	.text.uart_set_mcr6bit,"ax",%progbits
  90              		.align	2
  92              	uart_set_mcr6bit:
  93              	.LFB34:
 135:calypso/uart.c **** 	}
 136:calypso/uart.c **** }
 137:calypso/uart.c **** 
 138:calypso/uart.c **** /* Enable or disable the TCR_TLR latch bit in MCR[6] */
 139:calypso/uart.c **** static void uart_set_mcr6bit(int uart, int on)
 140:calypso/uart.c **** {
  94              		.loc 1 140 0
  95              		.cfi_startproc
  96              		@ args = 0, pretend = 0, frame = 0
  97              		@ frame_needed = 0, uses_anonymous_args = 0
  98              		@ link register save eliminated.
  99              	.LVL6:
 141:calypso/uart.c **** 	uint8_t mcr;
 142:calypso/uart.c **** 	/* we assume EFR[4] is always set to 1 */
 143:calypso/uart.c **** 	mcr = readb(UART_REG(uart, MCR));
 100              		.loc 1 143 0
 101 0000 20309FE5 		ldr	r3, .L15
 102 0004 033080E0 		add	r3, r0, r3
 103 0008 8335A0E1 		mov	r3, r3, asl #11
 104 000c 0420D3E5 		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 144:calypso/uart.c **** 	if (on)
 105              		.loc 1 144 0
 106 0010 000051E3 		cmp	r1, #0
 143:calypso/uart.c **** 	mcr = readb(UART_REG(uart, MCR));
 107              		.loc 1 143 0
 108 0014 FF0002E2 		and	r0, r2, #255
 109              	.LVL7:
 145:calypso/uart.c **** 		mcr |= (1 << 6);
 110              		.loc 1 145 0
 111 0018 40208013 		orrne	r2, r0, #64
 112              	.LVL8:
 146:calypso/uart.c **** 	else
 147:calypso/uart.c **** 		mcr &= ~(1 << 6);
 113              		.loc 1 147 0
 114 001c BF200202 		andeq	r2, r2, #191
 115              	.LVL9:
 148:calypso/uart.c **** 	writeb(mcr, UART_REG(uart, MCR));
 116              		.loc 1 148 0
 117 0020 0420C3E5 		strb	r2, [r3, #4]
 149:calypso/uart.c **** }
 118              		.loc 1 149 0
 119 0024 1EFF2FE1 		bx	lr
 120              	.L16:
 121              		.align	2
 122              	.L15:
 123 0028 EAFF1F00 		.word	2097130
 124              		.cfi_endproc
 125              	.LFE34:
 127              		.section	.text.uart_reg_write,"ax",%progbits
 128              		.align	2
 130              	uart_reg_write:
 131              	.LFB35:
 150:calypso/uart.c **** 
 151:calypso/uart.c **** static void uart_reg_write(int uart, enum uart_reg reg, uint8_t val)
 152:calypso/uart.c **** {
 132              		.loc 1 152 0
 133              		.cfi_startproc
 134              		@ args = 0, pretend = 0, frame = 0
 135              		@ frame_needed = 0, uses_anonymous_args = 0
 136              	.LVL10:
 137 0000 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 138              	.LCFI0:
 139              		.cfi_def_cfa_offset 20
 153:calypso/uart.c **** 	if (reg & LCRBFBIT)
 140              		.loc 1 153 0
 141 0004 406011E2 		ands	r6, r1, #64
 142              		.cfi_offset 14, -4
 143              		.cfi_offset 7, -8
 144              		.cfi_offset 6, -12
 145              		.cfi_offset 5, -16
 146              		.cfi_offset 4, -20
 152:calypso/uart.c **** {
 147              		.loc 1 152 0
 148 0008 0050A0E1 		mov	r5, r0
 149 000c 0140A0E1 		mov	r4, r1
 150 0010 0270A0E1 		mov	r7, r2
 151              		.loc 1 153 0
 152 0014 0200000A 		beq	.L18
 154:calypso/uart.c **** 		uart_set_lcr_bf(uart, 1);
 153              		.loc 1 154 0
 154 0018 0110A0E3 		mov	r1, #1
 155              	.LVL11:
 156 001c FEFFFFEB 		bl	uart_set_lcr_bf
 157              	.LVL12:
 158 0020 070000EA 		b	.L19
 159              	.LVL13:
 160              	.L18:
 155:calypso/uart.c **** 	else if (reg & LCR7BIT)
 161              		.loc 1 155 0
 162 0024 800011E3 		tst	r1, #128
 163 0028 0200000A 		beq	.L20
 156:calypso/uart.c **** 		uart_set_lcr7bit(uart, 1);
 164              		.loc 1 156 0
 165 002c 0110A0E3 		mov	r1, #1
 166 0030 FEFFFFEB 		bl	uart_set_lcr7bit
 167              	.LVL14:
 168 0034 020000EA 		b	.L19
 169              	.LVL15:
 170              	.L20:
 157:calypso/uart.c **** 	else if (reg & MCR6BIT)
 171              		.loc 1 157 0
 172 0038 200011E3 		tst	r1, #32
 158:calypso/uart.c **** 		uart_set_mcr6bit(uart, 1);
 173              		.loc 1 158 0
 174 003c 0110A013 		movne	r1, #1
 175 0040 FEFFFF1B 		blne	uart_set_mcr6bit
 176              	.LVL16:
 177              	.L19:
 159:calypso/uart.c **** 
 160:calypso/uart.c **** 	writeb(val, UART_REG(uart, REG_OFFS(reg)));
 178              		.loc 1 160 0
 179 0044 50309FE5 		ldr	r3, .L24
 180 0048 E020C4E3 		bic	r2, r4, #224
 181 004c 033085E0 		add	r3, r5, r3
 161:calypso/uart.c **** 
 162:calypso/uart.c **** 	if (reg & LCRBFBIT)
 182              		.loc 1 162 0
 183 0050 000056E3 		cmp	r6, #0
 160:calypso/uart.c **** 	writeb(val, UART_REG(uart, REG_OFFS(reg)));
 184              		.loc 1 160 0
 185 0054 8375C2E7 		strb	r7, [r2, r3, asl #11]
 186              		.loc 1 162 0
 187 0058 0300000A 		beq	.L21
 163:calypso/uart.c **** 		uart_set_lcr_bf(uart, 0);
 188              		.loc 1 163 0
 189 005c 0500A0E1 		mov	r0, r5
 190 0060 0010A0E3 		mov	r1, #0
 164:calypso/uart.c **** 	else if (reg & LCR7BIT)
 165:calypso/uart.c **** 		uart_set_lcr7bit(uart, 0);
 166:calypso/uart.c **** 	else if (reg & MCR6BIT)
 167:calypso/uart.c **** 		uart_set_mcr6bit(uart, 0);
 168:calypso/uart.c **** }
 191              		.loc 1 168 0
 192 0064 F040BDE8 		ldmfd	sp!, {r4, r5, r6, r7, lr}
 163:calypso/uart.c **** 		uart_set_lcr_bf(uart, 0);
 193              		.loc 1 163 0
 194 0068 FEFFFFEA 		b	uart_set_lcr_bf
 195              	.L21:
 164:calypso/uart.c **** 	else if (reg & LCR7BIT)
 196              		.loc 1 164 0
 197 006c 800014E3 		tst	r4, #128
 198 0070 0300000A 		beq	.L22
 165:calypso/uart.c **** 		uart_set_lcr7bit(uart, 0);
 199              		.loc 1 165 0
 200 0074 0500A0E1 		mov	r0, r5
 201 0078 0610A0E1 		mov	r1, r6
 202              		.loc 1 168 0
 203 007c F040BDE8 		ldmfd	sp!, {r4, r5, r6, r7, lr}
 165:calypso/uart.c **** 		uart_set_lcr7bit(uart, 0);
 204              		.loc 1 165 0
 205 0080 FEFFFFEA 		b	uart_set_lcr7bit
 206              	.L22:
 166:calypso/uart.c **** 	else if (reg & MCR6BIT)
 207              		.loc 1 166 0
 208 0084 200014E3 		tst	r4, #32
 209 0088 F080BD08 		ldmeqfd	sp!, {r4, r5, r6, r7, pc}
 167:calypso/uart.c **** 		uart_set_mcr6bit(uart, 0);
 210              		.loc 1 167 0
 211 008c 0500A0E1 		mov	r0, r5
 212 0090 0610A0E1 		mov	r1, r6
 213              		.loc 1 168 0
 214 0094 F040BDE8 		ldmfd	sp!, {r4, r5, r6, r7, lr}
 167:calypso/uart.c **** 		uart_set_mcr6bit(uart, 0);
 215              		.loc 1 167 0
 216 0098 FEFFFFEA 		b	uart_set_mcr6bit
 217              	.L25:
 218              		.align	2
 219              	.L24:
 220 009c EAFF1F00 		.word	2097130
 221              		.cfi_endproc
 222              	.LFE35:
 224              		.section	.text.uart_reg_read,"ax",%progbits
 225              		.align	2
 227              	uart_reg_read:
 228              	.LFB36:
 169:calypso/uart.c **** 
 170:calypso/uart.c **** /* read from a UART register, applying any required latch bits */
 171:calypso/uart.c **** static uint8_t uart_reg_read(int uart, enum uart_reg reg)
 172:calypso/uart.c **** {
 229              		.loc 1 172 0
 230              		.cfi_startproc
 231              		@ args = 0, pretend = 0, frame = 0
 232              		@ frame_needed = 0, uses_anonymous_args = 0
 233              	.LVL17:
 234 0000 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 235              	.LCFI1:
 236              		.cfi_def_cfa_offset 20
 173:calypso/uart.c **** 	uint8_t ret;
 174:calypso/uart.c **** 
 175:calypso/uart.c **** 	if (reg & LCRBFBIT)
 237              		.loc 1 175 0
 238 0004 406011E2 		ands	r6, r1, #64
 239              		.cfi_offset 14, -4
 240              		.cfi_offset 7, -8
 241              		.cfi_offset 6, -12
 242              		.cfi_offset 5, -16
 243              		.cfi_offset 4, -20
 172:calypso/uart.c **** {
 244              		.loc 1 172 0
 245 0008 0050A0E1 		mov	r5, r0
 246 000c 0140A0E1 		mov	r4, r1
 247              		.loc 1 175 0
 248 0010 0200000A 		beq	.L27
 176:calypso/uart.c **** 		uart_set_lcr_bf(uart, 1);
 249              		.loc 1 176 0
 250 0014 0110A0E3 		mov	r1, #1
 251              	.LVL18:
 252 0018 FEFFFFEB 		bl	uart_set_lcr_bf
 253              	.LVL19:
 254 001c 070000EA 		b	.L28
 255              	.L27:
 177:calypso/uart.c **** 	else if (reg & LCR7BIT)
 256              		.loc 1 177 0
 257 0020 800011E3 		tst	r1, #128
 258 0024 0200000A 		beq	.L29
 178:calypso/uart.c **** 		uart_set_lcr7bit(uart, 1);
 259              		.loc 1 178 0
 260 0028 0110A0E3 		mov	r1, #1
 261 002c FEFFFFEB 		bl	uart_set_lcr7bit
 262 0030 020000EA 		b	.L28
 263              	.L29:
 179:calypso/uart.c **** 	else if (reg & MCR6BIT)
 264              		.loc 1 179 0
 265 0034 200011E3 		tst	r1, #32
 180:calypso/uart.c **** 		uart_set_mcr6bit(uart, 1);
 266              		.loc 1 180 0
 267 0038 0110A013 		movne	r1, #1
 268 003c FEFFFF1B 		blne	uart_set_mcr6bit
 269              	.L28:
 181:calypso/uart.c **** 
 182:calypso/uart.c **** 	ret = readb(UART_REG(uart, REG_OFFS(reg)));
 270              		.loc 1 182 0
 271 0040 54309FE5 		ldr	r3, .L33
 272 0044 E020C4E3 		bic	r2, r4, #224
 273 0048 033085E0 		add	r3, r5, r3
 274 004c 8375D2E7 		ldrb	r7, [r2, r3, asl #11]	@ zero_extendqisi2
 183:calypso/uart.c **** 
 184:calypso/uart.c **** 	if (reg & LCRBFBIT)
 275              		.loc 1 184 0
 276 0050 000056E3 		cmp	r6, #0
 182:calypso/uart.c **** 	ret = readb(UART_REG(uart, REG_OFFS(reg)));
 277              		.loc 1 182 0
 278 0054 FF7007E2 		and	r7, r7, #255
 279              	.LVL20:
 280              		.loc 1 184 0
 281 0058 0300000A 		beq	.L30
 185:calypso/uart.c **** 		uart_set_lcr_bf(uart, 0);
 282              		.loc 1 185 0
 283 005c 0500A0E1 		mov	r0, r5
 284 0060 0010A0E3 		mov	r1, #0
 285 0064 FEFFFFEB 		bl	uart_set_lcr_bf
 286 0068 090000EA 		b	.L31
 287              	.L30:
 186:calypso/uart.c **** 	else if (reg & LCR7BIT)
 288              		.loc 1 186 0
 289 006c 800014E3 		tst	r4, #128
 290 0070 0300000A 		beq	.L32
 187:calypso/uart.c **** 		uart_set_lcr7bit(uart, 0);
 291              		.loc 1 187 0
 292 0074 0500A0E1 		mov	r0, r5
 293 0078 0610A0E1 		mov	r1, r6
 294 007c FEFFFFEB 		bl	uart_set_lcr7bit
 295 0080 030000EA 		b	.L31
 296              	.L32:
 188:calypso/uart.c **** 	else if (reg & MCR6BIT)
 297              		.loc 1 188 0
 298 0084 200014E3 		tst	r4, #32
 189:calypso/uart.c **** 		uart_set_mcr6bit(uart, 0);
 299              		.loc 1 189 0
 300 0088 0500A011 		movne	r0, r5
 301 008c 0610A011 		movne	r1, r6
 302 0090 FEFFFF1B 		blne	uart_set_mcr6bit
 303              	.L31:
 190:calypso/uart.c **** 
 191:calypso/uart.c **** 	return ret;
 192:calypso/uart.c **** }
 304              		.loc 1 192 0
 305 0094 0700A0E1 		mov	r0, r7
 306 0098 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 307              	.L34:
 308              		.align	2
 309              	.L33:
 310 009c EAFF1F00 		.word	2097130
 311              		.cfi_endproc
 312              	.LFE36:
 314              		.section	.text.uart_irq_handler_cons,"ax",%progbits
 315              		.align	2
 317              	uart_irq_handler_cons:
 318              	.LFB37:
 193:calypso/uart.c **** 
 194:calypso/uart.c **** static void uart_irq_handler_cons(__unused enum irq_nr irqnr)
 195:calypso/uart.c **** {
 319              		.loc 1 195 0
 320              		.cfi_startproc
 321              		@ args = 0, pretend = 0, frame = 0
 322              		@ frame_needed = 0, uses_anonymous_args = 0
 323              	.LVL21:
 324 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 325              	.LCFI2:
 326              		.cfi_def_cfa_offset 12
 196:calypso/uart.c **** 	const uint8_t uart = CONS_UART_NR;
 197:calypso/uart.c **** 	uint8_t iir;
 198:calypso/uart.c **** 
 199:calypso/uart.c **** 	//uart_putchar_nb(uart, 'U');
 200:calypso/uart.c **** 
 201:calypso/uart.c **** 	iir = uart_reg_read(uart, IIR);
 327              		.loc 1 201 0
 328 0004 0000A0E3 		mov	r0, #0
 329              	.LVL22:
 330 0008 0210A0E3 		mov	r1, #2
 331              		.cfi_offset 14, -4
 332              		.cfi_offset 5, -8
 333              		.cfi_offset 4, -12
 334 000c FEFFFFEB 		bl	uart_reg_read
 335              	.LVL23:
 202:calypso/uart.c **** 	if (iir & IIR_INT_PENDING)
 336              		.loc 1 202 0
 337 0010 015010E2 		ands	r5, r0, #1
 338 0014 3080BD18 		ldmnefd	sp!, {r4, r5, pc}
 203:calypso/uart.c **** 		return;
 204:calypso/uart.c **** 
 205:calypso/uart.c **** 	switch (iir & IIR_INT_TYPE) {
 339              		.loc 1 205 0
 340 0018 3E0000E2 		and	r0, r0, #62
 341              	.LVL24:
 342 001c 020050E3 		cmp	r0, #2
 343 0020 3080BD18 		ldmnefd	sp!, {r4, r5, pc}
 206:calypso/uart.c **** 	case IIR_INT_TYPE_RHR:
 207:calypso/uart.c **** 		break;
 208:calypso/uart.c **** 	case IIR_INT_TYPE_THR:
 209:calypso/uart.c **** 		if (cons_rb_flush() == 1) {
 344              		.loc 1 209 0
 345 0024 FEFFFFEB 		bl	cons_rb_flush
 346 0028 010050E3 		cmp	r0, #1
 347 002c 0040A0E1 		mov	r4, r0
 348 0030 3080BD18 		ldmnefd	sp!, {r4, r5, pc}
 349              	.LBB2:
 210:calypso/uart.c **** 			/* everything was flushed, disable THR IRQ */
 211:calypso/uart.c **** 			uint8_t ier = uart_reg_read(uart, IER);
 350              		.loc 1 211 0
 351 0034 0410A0E1 		mov	r1, r4
 352 0038 0500A0E1 		mov	r0, r5
 353 003c FEFFFFEB 		bl	uart_reg_read
 354              	.LVL25:
 212:calypso/uart.c **** 			ier &= ~(1 << 1);
 213:calypso/uart.c **** 			uart_reg_write(uart, IER, ier);
 355              		.loc 1 213 0
 356 0040 0410A0E1 		mov	r1, r4
 357 0044 FD2000E2 		and	r2, r0, #253
 358 0048 0500A0E1 		mov	r0, r5
 359              	.LVL26:
 360              	.LBE2:
 214:calypso/uart.c **** 		}
 215:calypso/uart.c **** 		break;
 216:calypso/uart.c **** 	case IIR_INT_TYPE_MSR:
 217:calypso/uart.c **** 		break;
 218:calypso/uart.c **** 	case IIR_INT_TYPE_RX_STATUS_ERROR:
 219:calypso/uart.c **** 		break;
 220:calypso/uart.c **** 	case IIR_INT_TYPE_RX_TIMEOUT:
 221:calypso/uart.c **** 		break;
 222:calypso/uart.c **** 	case IIR_INT_TYPE_XOFF:
 223:calypso/uart.c **** 		break;
 224:calypso/uart.c **** 	}
 225:calypso/uart.c **** }
 361              		.loc 1 225 0
 362 004c 3040BDE8 		ldmfd	sp!, {r4, r5, lr}
 363              	.LBB3:
 213:calypso/uart.c **** 			uart_reg_write(uart, IER, ier);
 364              		.loc 1 213 0
 365 0050 FEFFFFEA 		b	uart_reg_write
 366              	.LBE3:
 367              		.cfi_endproc
 368              	.LFE37:
 370              		.section	.text.uart_irq_enable,"ax",%progbits
 371              		.align	2
 372              		.global	uart_irq_enable
 374              	uart_irq_enable:
 375              	.LFB41:
 226:calypso/uart.c **** 
 227:calypso/uart.c **** static void uart_irq_handler_sercomm(__unused enum irq_nr irqnr)
 228:calypso/uart.c **** {
 229:calypso/uart.c **** 	const uint8_t uart = SERCOMM_UART_NR;
 230:calypso/uart.c **** 	uint8_t iir, ch;
 231:calypso/uart.c **** 
 232:calypso/uart.c **** 	//uart_putchar_nb(uart, 'U');
 233:calypso/uart.c **** 
 234:calypso/uart.c **** 	iir = uart_reg_read(uart, IIR);
 235:calypso/uart.c **** 	if (iir & IIR_INT_PENDING)
 236:calypso/uart.c **** 		return;
 237:calypso/uart.c **** 
 238:calypso/uart.c **** 	switch (iir & IIR_INT_TYPE) {
 239:calypso/uart.c **** 	case IIR_INT_TYPE_RX_TIMEOUT:
 240:calypso/uart.c **** 	case IIR_INT_TYPE_RHR:
 241:calypso/uart.c **** 		/* as long as we have rx data available */
 242:calypso/uart.c **** 		while (uart_getchar_nb(uart, &ch)) {
 243:calypso/uart.c **** 			if (sercomm_drv_rx_char(ch) < 0) {
 244:calypso/uart.c **** 				/* sercomm cannot receive more data right now */
 245:calypso/uart.c **** 				uart_irq_enable(uart, UART_IRQ_RX_CHAR, 0);
 246:calypso/uart.c **** 			}
 247:calypso/uart.c **** 		}
 248:calypso/uart.c **** 		break;
 249:calypso/uart.c **** 	case IIR_INT_TYPE_THR:
 250:calypso/uart.c **** 		/* as long as we have space in the FIFO */
 251:calypso/uart.c **** 		while (!uart_tx_busy(uart)) {
 252:calypso/uart.c **** 			/* get a byte from sercomm */
 253:calypso/uart.c **** 			if (!sercomm_drv_pull(&ch)) {
 254:calypso/uart.c **** 				/* no more bytes in sercomm, stop TX interrupts */
 255:calypso/uart.c **** 				uart_irq_enable(uart, UART_IRQ_TX_EMPTY, 0);
 256:calypso/uart.c **** 				break;
 257:calypso/uart.c **** 			}
 258:calypso/uart.c **** 			/* write the byte into the TX FIFO */
 259:calypso/uart.c **** 			uart_putchar_nb(uart, ch);
 260:calypso/uart.c **** 		}
 261:calypso/uart.c **** 		break;
 262:calypso/uart.c **** 	case IIR_INT_TYPE_MSR:
 263:calypso/uart.c **** 		printf("UART IRQ MSR\n");
 264:calypso/uart.c **** 		break;
 265:calypso/uart.c **** 	case IIR_INT_TYPE_RX_STATUS_ERROR:
 266:calypso/uart.c **** 		printf("UART IRQ RX_SE\n");
 267:calypso/uart.c **** 		break;
 268:calypso/uart.c **** 	case IIR_INT_TYPE_XOFF:
 269:calypso/uart.c **** 		printf("UART IRQXOFF\n");
 270:calypso/uart.c **** 		break;
 271:calypso/uart.c **** 	}
 272:calypso/uart.c **** }
 273:calypso/uart.c **** 
 274:calypso/uart.c **** static const uint8_t uart2irq[] = {
 275:calypso/uart.c **** 	[0]	= IRQ_UART_IRDA,
 276:calypso/uart.c **** 	[1]	= IRQ_UART_MODEM,
 277:calypso/uart.c **** };
 278:calypso/uart.c **** 
 279:calypso/uart.c **** void uart_init(uint8_t uart, uint8_t interrupts)
 280:calypso/uart.c **** {
 281:calypso/uart.c **** 	uint8_t irq = uart2irq[uart];
 282:calypso/uart.c **** 
 283:calypso/uart.c **** 	uart_reg_write(uart, IER, 0x00);
 284:calypso/uart.c **** 	if (uart == CONS_UART_NR) {
 285:calypso/uart.c **** 		cons_init();
 286:calypso/uart.c **** 		if(interrupts) {
 287:calypso/uart.c **** 			irq_register_handler(irq, &uart_irq_handler_cons);
 288:calypso/uart.c **** 			irq_config(irq, 0, 0, 0xff);
 289:calypso/uart.c **** 			irq_enable(irq);
 290:calypso/uart.c **** 		}
 291:calypso/uart.c **** 	} else {
 292:calypso/uart.c **** 		sercomm_init();
 293:calypso/uart.c **** 		if(interrupts) {
 294:calypso/uart.c **** 			irq_register_handler(irq, &uart_irq_handler_sercomm);
 295:calypso/uart.c **** 			irq_config(irq, 0, 0, 0xff);
 296:calypso/uart.c **** 			irq_enable(irq);
 297:calypso/uart.c **** 		}
 298:calypso/uart.c **** 		uart_irq_enable(uart, UART_IRQ_RX_CHAR, 1);
 299:calypso/uart.c **** 	}
 300:calypso/uart.c **** #if 0
 301:calypso/uart.c **** 	if (uart == 1) {
 302:calypso/uart.c **** 		/* assign UART to MCU and unmask interrupts*/
 303:calypso/uart.c **** 		writeb(UART_REG_UIR, 0x00);
 304:calypso/uart.c **** 	}
 305:calypso/uart.c **** #endif
 306:calypso/uart.c **** 
 307:calypso/uart.c **** 	/* if we don't initialize these, we get strange corruptions in the
 308:calypso/uart.c **** 	   received data... :-( */
 309:calypso/uart.c **** 	uart_reg_write(uart,  MDR1, 0x07); /* turn off UART */
 310:calypso/uart.c **** 	uart_reg_write(uart,  XON1, 0x00); /* Xon1/Addr Register */
 311:calypso/uart.c **** 	uart_reg_write(uart,  XON2, 0x00); /* Xon2/Addr Register */
 312:calypso/uart.c **** 	uart_reg_write(uart, XOFF1, 0x00); /* Xoff1 Register */
 313:calypso/uart.c **** 	uart_reg_write(uart, XOFF2, 0x00); /* Xoff2 Register */
 314:calypso/uart.c **** 	uart_reg_write(uart,   EFR, 0x00); /* Enhanced Features Register */
 315:calypso/uart.c **** 
 316:calypso/uart.c **** 	/* select  UART mode */
 317:calypso/uart.c **** 	uart_reg_write(uart, MDR1, 0);
 318:calypso/uart.c **** 	/* no XON/XOFF flow control, ENHANCED_EN, no auto-RTS/CTS */
 319:calypso/uart.c **** 	uart_reg_write(uart, EFR, (1 << 4));
 320:calypso/uart.c **** 	/* enable Tx/Rx FIFO, Tx trigger at 56 spaces, Rx trigger at 60 chars */
 321:calypso/uart.c **** 	uart_reg_write(uart, FCR, FIFO_EN | RX_FIFO_CLEAR | TX_FIFO_CLEAR |
 322:calypso/uart.c **** 			(3 << TX_FIFO_TRIG_SHIFT) | (3 << RX_FIFO_TRIG_SHIFT));
 323:calypso/uart.c **** 
 324:calypso/uart.c **** 	/* THR interrupt only when TX FIFO and TX shift register are empty */
 325:calypso/uart.c **** 	uart_reg_write(uart, SCR, (1 << 0));// | (1 << 3));
 326:calypso/uart.c **** 
 327:calypso/uart.c **** 	/* 8 bit, 1 stop bit, no parity, no break */
 328:calypso/uart.c **** 	uart_reg_write(uart, LCR, 0x03);
 329:calypso/uart.c **** 
 330:calypso/uart.c **** 	uart_set_lcr7bit(uart, 0);
 331:calypso/uart.c **** }
 332:calypso/uart.c **** 
 333:calypso/uart.c **** void uart_poll(uint8_t uart) {
 334:calypso/uart.c **** 	if(uart == CONS_UART_NR) {
 335:calypso/uart.c **** 		uart_irq_handler_cons(0);
 336:calypso/uart.c **** 	} else {
 337:calypso/uart.c **** 		uart_irq_handler_sercomm(0);
 338:calypso/uart.c **** 	}
 339:calypso/uart.c **** }
 340:calypso/uart.c **** 
 341:calypso/uart.c **** void uart_irq_enable(uint8_t uart, enum uart_irq irq, int on)
 342:calypso/uart.c **** {
 376              		.loc 1 342 0
 377              		.cfi_startproc
 378              		@ args = 0, pretend = 0, frame = 0
 379              		@ frame_needed = 0, uses_anonymous_args = 0
 380              	.LVL27:
 381 0000 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 382              	.LCFI3:
 383              		.cfi_def_cfa_offset 16
 384              		.loc 1 342 0
 385 0004 FF5000E2 		and	r5, r0, #255
 386              		.cfi_offset 14, -4
 387              		.cfi_offset 6, -8
 388              		.cfi_offset 5, -12
 389              		.cfi_offset 4, -16
 390 0008 0140A0E1 		mov	r4, r1
 343:calypso/uart.c **** 	uint8_t ier = uart_reg_read(uart, IER);
 391              		.loc 1 343 0
 392 000c 0500A0E1 		mov	r0, r5
 393              	.LVL28:
 394 0010 0110A0E3 		mov	r1, #1
 395              	.LVL29:
 342:calypso/uart.c **** {
 396              		.loc 1 342 0
 397 0014 0260A0E1 		mov	r6, r2
 398              		.loc 1 343 0
 399 0018 FEFFFFEB 		bl	uart_reg_read
 400              	.LVL30:
 401 001c 010054E3 		cmp	r4, #1
 402 0020 24309F95 		ldrls	r3, .L44
 403 0024 0430D397 		ldrlsb	r3, [r3, r4]	@ zero_extendqisi2
 404 0028 0030A083 		movhi	r3, #0
 405              	.LVL31:
 344:calypso/uart.c **** 	uint8_t mask = 0;
 345:calypso/uart.c **** 
 346:calypso/uart.c **** 	switch (irq) {
 347:calypso/uart.c **** 	case UART_IRQ_TX_EMPTY:
 348:calypso/uart.c **** 		mask = (1 << 1);
 349:calypso/uart.c **** 		break;
 350:calypso/uart.c **** 	case UART_IRQ_RX_CHAR:
 351:calypso/uart.c **** 		mask = (1 << 0);
 352:calypso/uart.c **** 		break;
 353:calypso/uart.c **** 	}
 354:calypso/uart.c **** 
 355:calypso/uart.c **** 	if (on)
 406              		.loc 1 355 0
 407 002c 000056E3 		cmp	r6, #0
 356:calypso/uart.c **** 		ier |= mask;
 408              		.loc 1 356 0
 409 0030 00208311 		orrne	r2, r3, r0
 357:calypso/uart.c **** 	else
 358:calypso/uart.c **** 		ier &= ~mask;
 410              		.loc 1 358 0
 411 0034 0320C001 		biceq	r2, r0, r3
 412 0038 FF2002E2 		and	r2, r2, #255
 413              	.LVL32:
 359:calypso/uart.c **** 
 360:calypso/uart.c **** 	uart_reg_write(uart, IER, ier);
 414              		.loc 1 360 0
 415 003c 0500A0E1 		mov	r0, r5
 416 0040 0110A0E3 		mov	r1, #1
 361:calypso/uart.c **** }
 417              		.loc 1 361 0
 418 0044 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 360:calypso/uart.c **** 	uart_reg_write(uart, IER, ier);
 419              		.loc 1 360 0
 420 0048 FEFFFFEA 		b	uart_reg_write
 421              	.LVL33:
 422              	.L45:
 423              		.align	2
 424              	.L44:
 425 004c 00000000 		.word	.LANCHOR1
 426              		.cfi_endproc
 427              	.LFE41:
 429              		.section	.text.uart_init,"ax",%progbits
 430              		.align	2
 431              		.global	uart_init
 433              	uart_init:
 434              	.LFB39:
 280:calypso/uart.c **** {
 435              		.loc 1 280 0
 436              		.cfi_startproc
 437              		@ args = 0, pretend = 0, frame = 0
 438              		@ frame_needed = 0, uses_anonymous_args = 0
 439              	.LVL34:
 281:calypso/uart.c **** 	uint8_t irq = uart2irq[uart];
 440              		.loc 1 281 0
 441 0000 64319FE5 		ldr	r3, .L50
 280:calypso/uart.c **** {
 442              		.loc 1 280 0
 443 0004 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 444              	.LCFI4:
 445              		.cfi_def_cfa_offset 16
 280:calypso/uart.c **** {
 446              		.loc 1 280 0
 447 0008 FF4000E2 		and	r4, r0, #255
 448              		.cfi_offset 14, -4
 449              		.cfi_offset 6, -8
 450              		.cfi_offset 5, -12
 451              		.cfi_offset 4, -16
 281:calypso/uart.c **** 	uint8_t irq = uart2irq[uart];
 452              		.loc 1 281 0
 453 000c 043083E0 		add	r3, r3, r4
 280:calypso/uart.c **** {
 454              		.loc 1 280 0
 455 0010 FF6001E2 		and	r6, r1, #255
 283:calypso/uart.c **** 	uart_reg_write(uart, IER, 0x00);
 456              		.loc 1 283 0
 457 0014 0400A0E1 		mov	r0, r4
 458              	.LVL35:
 459 0018 0110A0E3 		mov	r1, #1
 460              	.LVL36:
 461 001c 0020A0E3 		mov	r2, #0
 281:calypso/uart.c **** 	uint8_t irq = uart2irq[uart];
 462              		.loc 1 281 0
 463 0020 0450D3E5 		ldrb	r5, [r3, #4]	@ zero_extendqisi2
 464              	.LVL37:
 283:calypso/uart.c **** 	uart_reg_write(uart, IER, 0x00);
 465              		.loc 1 283 0
 466 0024 FEFFFFEB 		bl	uart_reg_write
 284:calypso/uart.c **** 	if (uart == CONS_UART_NR) {
 467              		.loc 1 284 0
 468 0028 000054E3 		cmp	r4, #0
 469 002c 0D00001A 		bne	.L47
 285:calypso/uart.c **** 		cons_init();
 470              		.loc 1 285 0
 471 0030 FEFFFFEB 		bl	cons_init
 286:calypso/uart.c **** 		if(interrupts) {
 472              		.loc 1 286 0
 473 0034 000056E3 		cmp	r6, #0
 474 0038 1B00000A 		beq	.L48
 287:calypso/uart.c **** 			irq_register_handler(irq, &uart_irq_handler_cons);
 475              		.loc 1 287 0
 476 003c 0500A0E1 		mov	r0, r5
 477 0040 28119FE5 		ldr	r1, .L50+4
 478 0044 FEFFFFEB 		bl	irq_register_handler
 288:calypso/uart.c **** 			irq_config(irq, 0, 0, 0xff);
 479              		.loc 1 288 0
 480 0048 0500A0E1 		mov	r0, r5
 481 004c 0410A0E1 		mov	r1, r4
 482 0050 0420A0E1 		mov	r2, r4
 483 0054 0030E0E3 		mvn	r3, #0
 484 0058 FEFFFFEB 		bl	irq_config
 289:calypso/uart.c **** 			irq_enable(irq);
 485              		.loc 1 289 0
 486 005c 0500A0E1 		mov	r0, r5
 487 0060 FEFFFFEB 		bl	irq_enable
 488 0064 100000EA 		b	.L48
 489              	.L47:
 292:calypso/uart.c **** 		sercomm_init();
 490              		.loc 1 292 0
 491 0068 FEFFFFEB 		bl	sercomm_init
 293:calypso/uart.c **** 		if(interrupts) {
 492              		.loc 1 293 0
 493 006c 000056E3 		cmp	r6, #0
 494 0070 0900000A 		beq	.L49
 294:calypso/uart.c **** 			irq_register_handler(irq, &uart_irq_handler_sercomm);
 495              		.loc 1 294 0
 496 0074 0500A0E1 		mov	r0, r5
 497 0078 F4109FE5 		ldr	r1, .L50+8
 498 007c FEFFFFEB 		bl	irq_register_handler
 295:calypso/uart.c **** 			irq_config(irq, 0, 0, 0xff);
 499              		.loc 1 295 0
 500 0080 0010A0E3 		mov	r1, #0
 501 0084 0500A0E1 		mov	r0, r5
 502 0088 0120A0E1 		mov	r2, r1
 503 008c 0030E0E3 		mvn	r3, #0
 504 0090 FEFFFFEB 		bl	irq_config
 296:calypso/uart.c **** 			irq_enable(irq);
 505              		.loc 1 296 0
 506 0094 0500A0E1 		mov	r0, r5
 507 0098 FEFFFFEB 		bl	irq_enable
 508              	.L49:
 298:calypso/uart.c **** 		uart_irq_enable(uart, UART_IRQ_RX_CHAR, 1);
 509              		.loc 1 298 0
 510 009c 0110A0E3 		mov	r1, #1
 511 00a0 0400A0E1 		mov	r0, r4
 512 00a4 0120A0E1 		mov	r2, r1
 513 00a8 FEFFFFEB 		bl	uart_irq_enable
 514              	.L48:
 309:calypso/uart.c **** 	uart_reg_write(uart,  MDR1, 0x07); /* turn off UART */
 515              		.loc 1 309 0
 516 00ac 0400A0E1 		mov	r0, r4
 517 00b0 0810A0E3 		mov	r1, #8
 518 00b4 0720A0E3 		mov	r2, #7
 519 00b8 FEFFFFEB 		bl	uart_reg_write
 310:calypso/uart.c **** 	uart_reg_write(uart,  XON1, 0x00); /* Xon1/Addr Register */
 520              		.loc 1 310 0
 521 00bc 0400A0E1 		mov	r0, r4
 522 00c0 4410A0E3 		mov	r1, #68
 523 00c4 0020A0E3 		mov	r2, #0
 524 00c8 FEFFFFEB 		bl	uart_reg_write
 311:calypso/uart.c **** 	uart_reg_write(uart,  XON2, 0x00); /* Xon2/Addr Register */
 525              		.loc 1 311 0
 526 00cc 0400A0E1 		mov	r0, r4
 527 00d0 4510A0E3 		mov	r1, #69
 528 00d4 0020A0E3 		mov	r2, #0
 529 00d8 FEFFFFEB 		bl	uart_reg_write
 312:calypso/uart.c **** 	uart_reg_write(uart, XOFF1, 0x00); /* Xoff1 Register */
 530              		.loc 1 312 0
 531 00dc 0400A0E1 		mov	r0, r4
 532 00e0 4610A0E3 		mov	r1, #70
 533 00e4 0020A0E3 		mov	r2, #0
 534 00e8 FEFFFFEB 		bl	uart_reg_write
 313:calypso/uart.c **** 	uart_reg_write(uart, XOFF2, 0x00); /* Xoff2 Register */
 535              		.loc 1 313 0
 536 00ec 0400A0E1 		mov	r0, r4
 537 00f0 4710A0E3 		mov	r1, #71
 538 00f4 0020A0E3 		mov	r2, #0
 539 00f8 FEFFFFEB 		bl	uart_reg_write
 314:calypso/uart.c **** 	uart_reg_write(uart,   EFR, 0x00); /* Enhanced Features Register */
 540              		.loc 1 314 0
 541 00fc 0400A0E1 		mov	r0, r4
 542 0100 4210A0E3 		mov	r1, #66
 543 0104 0020A0E3 		mov	r2, #0
 544 0108 FEFFFFEB 		bl	uart_reg_write
 317:calypso/uart.c **** 	uart_reg_write(uart, MDR1, 0);
 545              		.loc 1 317 0
 546 010c 0400A0E1 		mov	r0, r4
 547 0110 0810A0E3 		mov	r1, #8
 548 0114 0020A0E3 		mov	r2, #0
 549 0118 FEFFFFEB 		bl	uart_reg_write
 319:calypso/uart.c **** 	uart_reg_write(uart, EFR, (1 << 4));
 550              		.loc 1 319 0
 551 011c 0400A0E1 		mov	r0, r4
 552 0120 4210A0E3 		mov	r1, #66
 553 0124 1020A0E3 		mov	r2, #16
 554 0128 FEFFFFEB 		bl	uart_reg_write
 321:calypso/uart.c **** 	uart_reg_write(uart, FCR, FIFO_EN | RX_FIFO_CLEAR | TX_FIFO_CLEAR |
 555              		.loc 1 321 0
 556 012c 0400A0E1 		mov	r0, r4
 557 0130 0210A0E3 		mov	r1, #2
 558 0134 F720A0E3 		mov	r2, #247
 559 0138 FEFFFFEB 		bl	uart_reg_write
 325:calypso/uart.c **** 	uart_reg_write(uart, SCR, (1 << 0));// | (1 << 3));
 560              		.loc 1 325 0
 561 013c 0400A0E1 		mov	r0, r4
 562 0140 1010A0E3 		mov	r1, #16
 563 0144 0120A0E3 		mov	r2, #1
 564 0148 FEFFFFEB 		bl	uart_reg_write
 328:calypso/uart.c **** 	uart_reg_write(uart, LCR, 0x03);
 565              		.loc 1 328 0
 566 014c 0310A0E3 		mov	r1, #3
 567 0150 0400A0E1 		mov	r0, r4
 568 0154 0120A0E1 		mov	r2, r1
 569 0158 FEFFFFEB 		bl	uart_reg_write
 330:calypso/uart.c **** 	uart_set_lcr7bit(uart, 0);
 570              		.loc 1 330 0
 571 015c 0400A0E1 		mov	r0, r4
 572 0160 0010A0E3 		mov	r1, #0
 331:calypso/uart.c **** }
 573              		.loc 1 331 0
 574 0164 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 330:calypso/uart.c **** 	uart_set_lcr7bit(uart, 0);
 575              		.loc 1 330 0
 576 0168 FEFFFFEA 		b	uart_set_lcr7bit
 577              	.L51:
 578              		.align	2
 579              	.L50:
 580 016c 00000000 		.word	.LANCHOR1
 581 0170 00000000 		.word	uart_irq_handler_cons
 582 0174 00000000 		.word	uart_irq_handler_sercomm
 583              		.cfi_endproc
 584              	.LFE39:
 586              		.section	.text.uart_putchar_wait,"ax",%progbits
 587              		.align	2
 588              		.global	uart_putchar_wait
 590              	uart_putchar_wait:
 591              	.LFB42:
 362:calypso/uart.c **** 
 363:calypso/uart.c **** 
 364:calypso/uart.c **** void uart_putchar_wait(uint8_t uart, int c)
 365:calypso/uart.c **** {
 592              		.loc 1 365 0
 593              		.cfi_startproc
 594              		@ args = 0, pretend = 0, frame = 0
 595              		@ frame_needed = 0, uses_anonymous_args = 0
 596              		@ link register save eliminated.
 597              	.LVL38:
 366:calypso/uart.c **** 	/* wait while TX FIFO indicates full */
 367:calypso/uart.c **** 	while (readb(UART_REG(uart, SSR)) & 0x01) { }
 598              		.loc 1 367 0
 599 0000 24309FE5 		ldr	r3, .L55
 365:calypso/uart.c **** {
 600              		.loc 1 365 0
 601 0004 FF0000E2 		and	r0, r0, #255
 602              	.LVL39:
 603              		.loc 1 367 0
 604 0008 033080E0 		add	r3, r0, r3
 605 000c 8335A0E1 		mov	r3, r3, asl #11
 606 0010 112083E2 		add	r2, r3, #17
 607              	.L53:
 608              		.loc 1 367 0 is_stmt 0 discriminator 1
 609 0014 0000D2E5 		ldrb	r0, [r2, #0]	@ zero_extendqisi2
 610 0018 010010E3 		tst	r0, #1
 611 001c FCFFFF1A 		bne	.L53
 368:calypso/uart.c **** 
 369:calypso/uart.c **** 	/* put character in TX FIFO */
 370:calypso/uart.c **** 	writeb(c, UART_REG(uart, THR));
 612              		.loc 1 370 0 is_stmt 1
 613 0020 FF1001E2 		and	r1, r1, #255
 614              	.LVL40:
 615 0024 0010C3E5 		strb	r1, [r3, #0]
 371:calypso/uart.c **** }
 616              		.loc 1 371 0
 617 0028 1EFF2FE1 		bx	lr
 618              	.L56:
 619              		.align	2
 620              	.L55:
 621 002c EAFF1F00 		.word	2097130
 622              		.cfi_endproc
 623              	.LFE42:
 625              		.section	.text.uart_putchar_nb,"ax",%progbits
 626              		.align	2
 627              		.global	uart_putchar_nb
 629              	uart_putchar_nb:
 630              	.LFB43:
 372:calypso/uart.c **** 
 373:calypso/uart.c **** int uart_putchar_nb(uint8_t uart, int c)
 374:calypso/uart.c **** {
 631              		.loc 1 374 0
 632              		.cfi_startproc
 633              		@ args = 0, pretend = 0, frame = 0
 634              		@ frame_needed = 0, uses_anonymous_args = 0
 635              		@ link register save eliminated.
 636              	.LVL41:
 375:calypso/uart.c **** 	/* if TX FIFO indicates full, abort */
 376:calypso/uart.c **** 	if (readb(UART_REG(uart, SSR)) & 0x01)
 637              		.loc 1 376 0
 638 0000 24309FE5 		ldr	r3, .L60
 374:calypso/uart.c **** {
 639              		.loc 1 374 0
 640 0004 FF0000E2 		and	r0, r0, #255
 641              	.LVL42:
 642              		.loc 1 376 0
 643 0008 033080E0 		add	r3, r0, r3
 644 000c 8335A0E1 		mov	r3, r3, asl #11
 645 0010 1120D3E5 		ldrb	r2, [r3, #17]	@ zero_extendqisi2
 646 0014 010012E3 		tst	r2, #1
 377:calypso/uart.c **** 		return 0;
 378:calypso/uart.c **** 
 379:calypso/uart.c **** 	writeb(c, UART_REG(uart, THR));
 647              		.loc 1 379 0
 648 0018 FF100102 		andeq	r1, r1, #255
 649              	.LVL43:
 650 001c 0010C305 		streqb	r1, [r3, #0]
 380:calypso/uart.c **** 	return 1;
 651              		.loc 1 380 0
 652 0020 0100A003 		moveq	r0, #1
 377:calypso/uart.c **** 		return 0;
 653              		.loc 1 377 0
 654 0024 0000A013 		movne	r0, #0
 381:calypso/uart.c **** }
 655              		.loc 1 381 0
 656 0028 1EFF2FE1 		bx	lr
 657              	.L61:
 658              		.align	2
 659              	.L60:
 660 002c EAFF1F00 		.word	2097130
 661              		.cfi_endproc
 662              	.LFE43:
 664              		.section	.text.uart_getchar_nb,"ax",%progbits
 665              		.align	2
 666              		.global	uart_getchar_nb
 668              	uart_getchar_nb:
 669              	.LFB44:
 382:calypso/uart.c **** 
 383:calypso/uart.c **** int uart_getchar_nb(uint8_t uart, uint8_t *ch)
 384:calypso/uart.c **** {
 670              		.loc 1 384 0
 671              		.cfi_startproc
 672              		@ args = 0, pretend = 0, frame = 0
 673              		@ frame_needed = 0, uses_anonymous_args = 0
 674              	.LVL44:
 675 0000 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 676              	.LCFI5:
 677              		.cfi_def_cfa_offset 16
 385:calypso/uart.c **** 	uint8_t lsr;
 386:calypso/uart.c **** 
 387:calypso/uart.c **** 	lsr = readb(UART_REG(uart, LSR));
 678              		.loc 1 387 0
 679 0004 64509FE5 		ldr	r5, .L70
 680              		.cfi_offset 14, -4
 681              		.cfi_offset 6, -8
 682              		.cfi_offset 5, -12
 683              		.cfi_offset 4, -16
 384:calypso/uart.c **** {
 684              		.loc 1 384 0
 685 0008 FF0000E2 		and	r0, r0, #255
 686              	.LVL45:
 687              		.loc 1 387 0
 688 000c 055080E0 		add	r5, r0, r5
 689 0010 8555A0E1 		mov	r5, r5, asl #11
 690 0014 0530D5E5 		ldrb	r3, [r5, #5]	@ zero_extendqisi2
 388:calypso/uart.c **** 
 389:calypso/uart.c **** 	/* something strange happened */
 390:calypso/uart.c **** 	if (lsr & 0x02)
 691              		.loc 1 390 0
 692 0018 020013E3 		tst	r3, #2
 384:calypso/uart.c **** {
 693              		.loc 1 384 0
 694 001c 0160A0E1 		mov	r6, r1
 387:calypso/uart.c **** 	lsr = readb(UART_REG(uart, LSR));
 695              		.loc 1 387 0
 696 0020 FF4003E2 		and	r4, r3, #255
 697              	.LVL46:
 698              		.loc 1 390 0
 391:calypso/uart.c **** 		printf("LSR RX_OE\n");
 699              		.loc 1 391 0
 700 0024 48009F15 		ldrne	r0, .L70+4
 701 0028 FEFFFF1B 		blne	puts
 702              	.LVL47:
 703              	.L63:
 392:calypso/uart.c **** 	if (lsr & 0x04)
 704              		.loc 1 392 0
 705 002c 040014E3 		tst	r4, #4
 393:calypso/uart.c **** 		printf("LSR RX_PE\n");
 706              		.loc 1 393 0
 707 0030 40009F15 		ldrne	r0, .L70+8
 708 0034 FEFFFF1B 		blne	puts
 709              	.L64:
 394:calypso/uart.c **** 	if (lsr & 0x08)
 710              		.loc 1 394 0
 711 0038 080014E3 		tst	r4, #8
 395:calypso/uart.c **** 		printf("LSR RX_FE\n");
 712              		.loc 1 395 0
 713 003c 38009F15 		ldrne	r0, .L70+12
 714 0040 FEFFFF1B 		blne	puts
 715              	.L65:
 396:calypso/uart.c **** 	if (lsr & 0x10)
 716              		.loc 1 396 0
 717 0044 100014E3 		tst	r4, #16
 397:calypso/uart.c **** 		printf("LSR RX_BI\n");
 718              		.loc 1 397 0
 719 0048 30009F15 		ldrne	r0, .L70+16
 720 004c FEFFFF1B 		blne	puts
 721              	.L66:
 398:calypso/uart.c **** 	if (lsr & 0x80)
 722              		.loc 1 398 0
 723 0050 800014E3 		tst	r4, #128
 399:calypso/uart.c **** 		printf("LSR RX_FIFO_STS\n");
 724              		.loc 1 399 0
 725 0054 28009F15 		ldrne	r0, .L70+20
 726 0058 FEFFFF1B 		blne	puts
 727              	.L67:
 400:calypso/uart.c **** 
 401:calypso/uart.c **** 	/* is the Rx FIFO empty? */
 402:calypso/uart.c **** 	if (!(lsr & 0x01))
 728              		.loc 1 402 0
 729 005c 010014E2 		ands	r0, r4, #1
 403:calypso/uart.c **** 		return 0;
 404:calypso/uart.c **** 
 405:calypso/uart.c **** 	*ch = readb(UART_REG(uart, RHR));
 730              		.loc 1 405 0
 731 0060 0030D515 		ldrneb	r3, [r5, #0]	@ zero_extendqisi2
 406:calypso/uart.c **** 	//printf("getchar_nb(%u) = %02x\n", uart, *ch);
 407:calypso/uart.c **** 	return 1;
 732              		.loc 1 407 0
 733 0064 0100A013 		movne	r0, #1
 405:calypso/uart.c **** 	*ch = readb(UART_REG(uart, RHR));
 734              		.loc 1 405 0
 735 0068 0030C615 		strneb	r3, [r6, #0]
 408:calypso/uart.c **** }
 736              		.loc 1 408 0
 737 006c 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 738              	.L71:
 739              		.align	2
 740              	.L70:
 741 0070 EAFF1F00 		.word	2097130
 742 0074 00000000 		.word	.LC0
 743 0078 0A000000 		.word	.LC1
 744 007c 14000000 		.word	.LC2
 745 0080 1E000000 		.word	.LC3
 746 0084 28000000 		.word	.LC4
 747              		.cfi_endproc
 748              	.LFE44:
 750              		.section	.text.uart_tx_busy,"ax",%progbits
 751              		.align	2
 752              		.global	uart_tx_busy
 754              	uart_tx_busy:
 755              	.LFB45:
 409:calypso/uart.c **** 
 410:calypso/uart.c **** int uart_tx_busy(uint8_t uart)
 411:calypso/uart.c **** {
 756              		.loc 1 411 0
 757              		.cfi_startproc
 758              		@ args = 0, pretend = 0, frame = 0
 759              		@ frame_needed = 0, uses_anonymous_args = 0
 760              		@ link register save eliminated.
 761              	.LVL48:
 412:calypso/uart.c **** 	if (readb(UART_REG(uart, SSR)) & 0x01)
 762              		.loc 1 412 0
 763 0000 14309FE5 		ldr	r3, .L73
 411:calypso/uart.c **** {
 764              		.loc 1 411 0
 765 0004 FF0000E2 		and	r0, r0, #255
 766              	.LVL49:
 767              		.loc 1 412 0
 768 0008 033080E0 		add	r3, r0, r3
 769 000c 8335A0E1 		mov	r3, r3, asl #11
 770 0010 1100D3E5 		ldrb	r0, [r3, #17]	@ zero_extendqisi2
 413:calypso/uart.c **** 		return 1;
 414:calypso/uart.c **** 	return 0;
 415:calypso/uart.c **** }
 771              		.loc 1 415 0
 772 0014 010000E2 		and	r0, r0, #1
 773 0018 1EFF2FE1 		bx	lr
 774              	.L74:
 775              		.align	2
 776              	.L73:
 777 001c EAFF1F00 		.word	2097130
 778              		.cfi_endproc
 779              	.LFE45:
 781              		.section	.text.uart_irq_handler_sercomm,"ax",%progbits
 782              		.align	2
 784              	uart_irq_handler_sercomm:
 785              	.LFB38:
 228:calypso/uart.c **** {
 786              		.loc 1 228 0
 787              		.cfi_startproc
 788              		@ args = 0, pretend = 0, frame = 4
 789              		@ frame_needed = 0, uses_anonymous_args = 0
 790              	.LVL50:
 791 0000 11402DE9 		stmfd	sp!, {r0, r4, lr}
 792              	.LCFI6:
 793              		.cfi_def_cfa_offset 12
 234:calypso/uart.c **** 	iir = uart_reg_read(uart, IIR);
 794              		.loc 1 234 0
 795 0004 0210A0E3 		mov	r1, #2
 796 0008 0100A0E3 		mov	r0, #1
 797              		.cfi_offset 14, -4
 798              		.cfi_offset 4, -8
 799              		.cfi_offset 0, -12
 800              	.LVL51:
 801 000c FEFFFFEB 		bl	uart_reg_read
 802              	.LVL52:
 235:calypso/uart.c **** 	if (iir & IIR_INT_PENDING)
 803              		.loc 1 235 0
 804 0010 010010E3 		tst	r0, #1
 805 0014 3C00001A 		bne	.L75
 238:calypso/uart.c **** 	switch (iir & IIR_INT_TYPE) {
 806              		.loc 1 238 0
 807 0018 3E0000E2 		and	r0, r0, #62
 808              	.LVL53:
 809 001c 100050E3 		cmp	r0, #16
 810 0020 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 811 0024 380000EA 		b	.L75
 812              	.L82:
 813 0028 F4000000 		.word	.L77
 814 002c 0C010000 		.word	.L75
 815 0030 DC000000 		.word	.L78
 816 0034 0C010000 		.word	.L75
 817 0038 90000000 		.word	.L88
 818 003c 0C010000 		.word	.L75
 819 0040 FC000000 		.word	.L80
 820 0044 0C010000 		.word	.L75
 821 0048 0C010000 		.word	.L75
 822 004c 0C010000 		.word	.L75
 823 0050 0C010000 		.word	.L75
 824 0054 0C010000 		.word	.L75
 825 0058 90000000 		.word	.L88
 826 005c 0C010000 		.word	.L75
 827 0060 0C010000 		.word	.L75
 828 0064 0C010000 		.word	.L75
 829 0068 04010000 		.word	.L81
 830              	.LVL54:
 831              	.L84:
 243:calypso/uart.c **** 			if (sercomm_drv_rx_char(ch) < 0) {
 832              		.loc 1 243 0
 833 006c 0300DDE5 		ldrb	r0, [sp, #3]	@ zero_extendqisi2
 834 0070 FEFFFFEB 		bl	sercomm_drv_rx_char
 835 0074 000050E3 		cmp	r0, #0
 836 0078 050000AA 		bge	.L90
 245:calypso/uart.c **** 				uart_irq_enable(uart, UART_IRQ_RX_CHAR, 0);
 837              		.loc 1 245 0
 838 007c 0100A0E3 		mov	r0, #1
 839 0080 0010A0E1 		mov	r1, r0
 840 0084 0020A0E3 		mov	r2, #0
 841 0088 FEFFFFEB 		bl	uart_irq_enable
 842 008c 000000EA 		b	.L90
 843              	.LVL55:
 844              	.L88:
 242:calypso/uart.c **** 		while (uart_getchar_nb(uart, &ch)) {
 845              		.loc 1 242 0 discriminator 1
 846 0090 03408DE2 		add	r4, sp, #3
 847              	.LVL56:
 848              	.L90:
 849 0094 0100A0E3 		mov	r0, #1
 850 0098 0410A0E1 		mov	r1, r4
 851 009c FEFFFFEB 		bl	uart_getchar_nb
 852 00a0 000050E3 		cmp	r0, #0
 853 00a4 F0FFFF1A 		bne	.L84
 854 00a8 170000EA 		b	.L75
 855              	.L86:
 253:calypso/uart.c **** 			if (!sercomm_drv_pull(&ch)) {
 856              		.loc 1 253 0
 857 00ac 0400A0E1 		mov	r0, r4
 858 00b0 FEFFFFEB 		bl	sercomm_drv_pull
 859 00b4 001050E2 		subs	r1, r0, #0
 860 00b8 0300001A 		bne	.L85
 255:calypso/uart.c **** 				uart_irq_enable(uart, UART_IRQ_TX_EMPTY, 0);
 861              		.loc 1 255 0
 862 00bc 010080E2 		add	r0, r0, #1
 863 00c0 0120A0E1 		mov	r2, r1
 864 00c4 FEFFFFEB 		bl	uart_irq_enable
 256:calypso/uart.c **** 				break;
 865              		.loc 1 256 0
 866 00c8 0F0000EA 		b	.L75
 867              	.L85:
 259:calypso/uart.c **** 			uart_putchar_nb(uart, ch);
 868              		.loc 1 259 0
 869 00cc 0310DDE5 		ldrb	r1, [sp, #3]	@ zero_extendqisi2
 870 00d0 0100A0E3 		mov	r0, #1
 871 00d4 FEFFFFEB 		bl	uart_putchar_nb
 872 00d8 000000EA 		b	.L91
 873              	.LVL57:
 874              	.L78:
 253:calypso/uart.c **** 			if (!sercomm_drv_pull(&ch)) {
 875              		.loc 1 253 0 discriminator 1
 876 00dc 03408DE2 		add	r4, sp, #3
 877              	.LVL58:
 878              	.L91:
 251:calypso/uart.c **** 		while (!uart_tx_busy(uart)) {
 879              		.loc 1 251 0 discriminator 1
 880 00e0 0100A0E3 		mov	r0, #1
 881 00e4 FEFFFFEB 		bl	uart_tx_busy
 882 00e8 000050E3 		cmp	r0, #0
 883 00ec EEFFFF0A 		beq	.L86
 884 00f0 050000EA 		b	.L75
 885              	.LVL59:
 886              	.L77:
 263:calypso/uart.c **** 		printf("UART IRQ MSR\n");
 887              		.loc 1 263 0
 888 00f4 14009FE5 		ldr	r0, .L93
 889 00f8 020000EA 		b	.L92
 890              	.L80:
 266:calypso/uart.c **** 		printf("UART IRQ RX_SE\n");
 891              		.loc 1 266 0
 892 00fc 10009FE5 		ldr	r0, .L93+4
 893 0100 000000EA 		b	.L92
 894              	.L81:
 269:calypso/uart.c **** 		printf("UART IRQXOFF\n");
 895              		.loc 1 269 0
 896 0104 0C009FE5 		ldr	r0, .L93+8
 897              	.L92:
 898 0108 FEFFFFEB 		bl	puts
 899              	.LVL60:
 900              	.L75:
 272:calypso/uart.c **** }
 901              		.loc 1 272 0
 902 010c 1880BDE8 		ldmfd	sp!, {r3, r4, pc}
 903              	.L94:
 904              		.align	2
 905              	.L93:
 906 0110 38000000 		.word	.LC5
 907 0114 45000000 		.word	.LC6
 908 0118 54000000 		.word	.LC7
 909              		.cfi_endproc
 910              	.LFE38:
 912              		.section	.text.uart_poll,"ax",%progbits
 913              		.align	2
 914              		.global	uart_poll
 916              	uart_poll:
 917              	.LFB40:
 333:calypso/uart.c **** void uart_poll(uint8_t uart) {
 918              		.loc 1 333 0
 919              		.cfi_startproc
 920              		@ args = 0, pretend = 0, frame = 0
 921              		@ frame_needed = 0, uses_anonymous_args = 0
 922              		@ link register save eliminated.
 923              	.LVL61:
 334:calypso/uart.c **** 	if(uart == CONS_UART_NR) {
 924              		.loc 1 334 0
 925 0000 FF0010E2 		ands	r0, r0, #255
 926              	.LVL62:
 927 0004 0000001A 		bne	.L96
 339:calypso/uart.c **** }
 928              		.loc 1 339 0
 335:calypso/uart.c **** 		uart_irq_handler_cons(0);
 929              		.loc 1 335 0
 930 0008 FEFFFFEA 		b	uart_irq_handler_cons
 931              	.L96:
 337:calypso/uart.c **** 		uart_irq_handler_sercomm(0);
 932              		.loc 1 337 0
 933 000c 0000A0E3 		mov	r0, #0
 339:calypso/uart.c **** }
 934              		.loc 1 339 0
 337:calypso/uart.c **** 		uart_irq_handler_sercomm(0);
 935              		.loc 1 337 0
 936 0010 FEFFFFEA 		b	uart_irq_handler_sercomm
 937              		.cfi_endproc
 938              	.LFE40:
 940              		.section	.text.uart_baudrate,"ax",%progbits
 941              		.align	2
 942              		.global	uart_baudrate
 944              	uart_baudrate:
 945              	.LFB46:
 416:calypso/uart.c **** 
 417:calypso/uart.c **** static const uint16_t divider[] = {
 418:calypso/uart.c **** 	[UART_38400]	= 21,	/*   38,690 */
 419:calypso/uart.c **** 	[UART_57600]	= 14,	/*   58,035 */
 420:calypso/uart.c **** 	[UART_115200]	= 7,	/*  116,071 */
 421:calypso/uart.c **** 	[UART_230400]	= 4,	/*  203,125! (-3% would be 223,488) */
 422:calypso/uart.c **** 	[UART_460800]	= 2,	/*  406,250! (-3% would be 446,976) */
 423:calypso/uart.c **** 	[UART_921600]	= 1,	/*  812,500! (-3% would be 893,952) */
 424:calypso/uart.c **** };
 425:calypso/uart.c **** 
 426:calypso/uart.c **** int uart_baudrate(uint8_t uart, enum uart_baudrate bdrt)
 427:calypso/uart.c **** {
 946              		.loc 1 427 0
 947              		.cfi_startproc
 948              		@ args = 0, pretend = 0, frame = 0
 949              		@ frame_needed = 0, uses_anonymous_args = 0
 950              	.LVL63:
 428:calypso/uart.c **** 	uint16_t div;
 429:calypso/uart.c **** 
 430:calypso/uart.c **** 	if (bdrt >= ARRAY_SIZE(divider))
 951              		.loc 1 430 0
 952 0000 060051E3 		cmp	r1, #6
 427:calypso/uart.c **** {
 953              		.loc 1 427 0
 954 0004 30402DE9 		stmfd	sp!, {r4, r5, lr}
 955              	.LCFI7:
 956              		.cfi_def_cfa_offset 12
 427:calypso/uart.c **** {
 957              		.loc 1 427 0
 958 0008 FF4000E2 		and	r4, r0, #255
 959              		.cfi_offset 14, -4
 960              		.cfi_offset 5, -8
 961              		.cfi_offset 4, -12
 962              		.loc 1 430 0
 963 000c 1100008A 		bhi	.L99
 431:calypso/uart.c **** 		return -1;
 432:calypso/uart.c **** 
 433:calypso/uart.c **** 	div = divider[bdrt];
 964              		.loc 1 433 0
 965 0010 48309FE5 		ldr	r3, .L100
 966 0014 811083E0 		add	r1, r3, r1, asl #1
 967              	.LVL64:
 968 0018 B850D1E1 		ldrh	r5, [r1, #8]
 969              	.LVL65:
 434:calypso/uart.c **** 	uart_set_lcr7bit(uart, 1);
 970              		.loc 1 434 0
 971 001c 0400A0E1 		mov	r0, r4
 972              	.LVL66:
 973 0020 0110A0E3 		mov	r1, #1
 974 0024 FEFFFFEB 		bl	uart_set_lcr7bit
 435:calypso/uart.c **** 	writeb(div & 0xff, UART_REG(uart, DLL));
 975              		.loc 1 435 0
 976 0028 34309FE5 		ldr	r3, .L100+4
 977 002c 033084E0 		add	r3, r4, r3
 978 0030 8335A0E1 		mov	r3, r3, asl #11
 979 0034 FF2005E2 		and	r2, r5, #255
 436:calypso/uart.c **** 	writeb(div >> 8, UART_REG(uart, DLH));
 980              		.loc 1 436 0
 981 0038 2554A0E1 		mov	r5, r5, lsr #8
 982              	.LVL67:
 435:calypso/uart.c **** 	writeb(div & 0xff, UART_REG(uart, DLL));
 983              		.loc 1 435 0
 984 003c 8020C3E5 		strb	r2, [r3, #128]
 437:calypso/uart.c **** 	uart_set_lcr7bit(uart, 0);
 985              		.loc 1 437 0
 986 0040 0400A0E1 		mov	r0, r4
 436:calypso/uart.c **** 	writeb(div >> 8, UART_REG(uart, DLH));
 987              		.loc 1 436 0
 988 0044 8150C3E5 		strb	r5, [r3, #129]
 989              		.loc 1 437 0
 990 0048 0010A0E3 		mov	r1, #0
 991 004c FEFFFFEB 		bl	uart_set_lcr7bit
 438:calypso/uart.c **** 
 439:calypso/uart.c **** 	return 0;
 992              		.loc 1 439 0
 993 0050 0000A0E3 		mov	r0, #0
 994 0054 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 995              	.LVL68:
 996              	.L99:
 431:calypso/uart.c **** 		return -1;
 997              		.loc 1 431 0
 998 0058 0000E0E3 		mvn	r0, #0
 999              	.LVL69:
 440:calypso/uart.c **** }
 1000              		.loc 1 440 0
 1001 005c 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 1002              	.L101:
 1003              		.align	2
 1004              	.L100:
 1005 0060 00000000 		.word	.LANCHOR1
 1006 0064 EAFF1F00 		.word	2097130
 1007              		.cfi_endproc
 1008              	.LFE46:
 1010              		.section	.rodata
 1011              		.align	2
 1012              		.set	.LANCHOR1,. + 0
 1015              	CSWTCH.12:
 1016 0000 02       		.byte	2
 1017 0001 01       		.byte	1
 1018 0002 0000     		.space	2
 1021              	uart2irq:
 1022 0004 12       		.byte	18
 1023 0005 07       		.byte	7
 1024 0006 0000     		.space	2
 1027              	divider:
 1028 0008 1500     		.short	21
 1029 000a 0E00     		.short	14
 1030 000c 0700     		.short	7
 1031 000e 0400     		.short	4
 1032 0010 0200     		.short	2
 1033 0012 0000     		.space	2
 1034 0014 0100     		.short	1
 1035 0016 0000     		.section	.rodata.str1.1,"aMS",%progbits,1
 1036              	.LC0:
 1037 0000 4C535220 		.ascii	"LSR RX_OE\000"
 1037      52585F4F 
 1037      4500
 1038              	.LC1:
 1039 000a 4C535220 		.ascii	"LSR RX_PE\000"
 1039      52585F50 
 1039      4500
 1040              	.LC2:
 1041 0014 4C535220 		.ascii	"LSR RX_FE\000"
 1041      52585F46 
 1041      4500
 1042              	.LC3:
 1043 001e 4C535220 		.ascii	"LSR RX_BI\000"
 1043      52585F42 
 1043      4900
 1044              	.LC4:
 1045 0028 4C535220 		.ascii	"LSR RX_FIFO_STS\000"
 1045      52585F46 
 1045      49464F5F 
 1045      53545300 
 1046              	.LC5:
 1047 0038 55415254 		.ascii	"UART IRQ MSR\000"
 1047      20495251 
 1047      204D5352 
 1047      00
 1048              	.LC6:
 1049 0045 55415254 		.ascii	"UART IRQ RX_SE\000"
 1049      20495251 
 1049      2052585F 
 1049      534500
 1050              	.LC7:
 1051 0054 55415254 		.ascii	"UART IRQXOFF\000"
 1051      20495251 
 1051      584F4646 
 1051      00
 1052              		.bss
 1053              		.set	.LANCHOR0,. + 0
 1056              	old_lcr:
 1057 0000 00       		.space	1
 1058              		.text
 1059              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 uart.c
     /tmp/ccG8hgbC.s:12     .text.uart_set_lcr7bit:0000000000000000 $a
     /tmp/ccG8hgbC.s:14     .text.uart_set_lcr7bit:0000000000000000 uart_set_lcr7bit
     /tmp/ccG8hgbC.s:46     .text.uart_set_lcr7bit:0000000000000028 $d
     /tmp/ccG8hgbC.s:51     .text.uart_set_lcr_bf:0000000000000000 $a
     /tmp/ccG8hgbC.s:53     .text.uart_set_lcr_bf:0000000000000000 uart_set_lcr_bf
     /tmp/ccG8hgbC.s:84     .text.uart_set_lcr_bf:0000000000000030 $d
     /tmp/ccG8hgbC.s:90     .text.uart_set_mcr6bit:0000000000000000 $a
     /tmp/ccG8hgbC.s:92     .text.uart_set_mcr6bit:0000000000000000 uart_set_mcr6bit
     /tmp/ccG8hgbC.s:123    .text.uart_set_mcr6bit:0000000000000028 $d
     /tmp/ccG8hgbC.s:128    .text.uart_reg_write:0000000000000000 $a
     /tmp/ccG8hgbC.s:130    .text.uart_reg_write:0000000000000000 uart_reg_write
     /tmp/ccG8hgbC.s:220    .text.uart_reg_write:000000000000009c $d
     /tmp/ccG8hgbC.s:225    .text.uart_reg_read:0000000000000000 $a
     /tmp/ccG8hgbC.s:227    .text.uart_reg_read:0000000000000000 uart_reg_read
     /tmp/ccG8hgbC.s:310    .text.uart_reg_read:000000000000009c $d
     /tmp/ccG8hgbC.s:315    .text.uart_irq_handler_cons:0000000000000000 $a
     /tmp/ccG8hgbC.s:317    .text.uart_irq_handler_cons:0000000000000000 uart_irq_handler_cons
     /tmp/ccG8hgbC.s:371    .text.uart_irq_enable:0000000000000000 $a
     /tmp/ccG8hgbC.s:374    .text.uart_irq_enable:0000000000000000 uart_irq_enable
     /tmp/ccG8hgbC.s:425    .text.uart_irq_enable:000000000000004c $d
     /tmp/ccG8hgbC.s:430    .text.uart_init:0000000000000000 $a
     /tmp/ccG8hgbC.s:433    .text.uart_init:0000000000000000 uart_init
     /tmp/ccG8hgbC.s:580    .text.uart_init:000000000000016c $d
     /tmp/ccG8hgbC.s:784    .text.uart_irq_handler_sercomm:0000000000000000 uart_irq_handler_sercomm
     /tmp/ccG8hgbC.s:587    .text.uart_putchar_wait:0000000000000000 $a
     /tmp/ccG8hgbC.s:590    .text.uart_putchar_wait:0000000000000000 uart_putchar_wait
     /tmp/ccG8hgbC.s:621    .text.uart_putchar_wait:000000000000002c $d
     /tmp/ccG8hgbC.s:626    .text.uart_putchar_nb:0000000000000000 $a
     /tmp/ccG8hgbC.s:629    .text.uart_putchar_nb:0000000000000000 uart_putchar_nb
     /tmp/ccG8hgbC.s:660    .text.uart_putchar_nb:000000000000002c $d
     /tmp/ccG8hgbC.s:665    .text.uart_getchar_nb:0000000000000000 $a
     /tmp/ccG8hgbC.s:668    .text.uart_getchar_nb:0000000000000000 uart_getchar_nb
     /tmp/ccG8hgbC.s:741    .text.uart_getchar_nb:0000000000000070 $d
     /tmp/ccG8hgbC.s:751    .text.uart_tx_busy:0000000000000000 $a
     /tmp/ccG8hgbC.s:754    .text.uart_tx_busy:0000000000000000 uart_tx_busy
     /tmp/ccG8hgbC.s:777    .text.uart_tx_busy:000000000000001c $d
     /tmp/ccG8hgbC.s:782    .text.uart_irq_handler_sercomm:0000000000000000 $a
     /tmp/ccG8hgbC.s:813    .text.uart_irq_handler_sercomm:0000000000000028 $d
     /tmp/ccG8hgbC.s:833    .text.uart_irq_handler_sercomm:000000000000006c $a
     /tmp/ccG8hgbC.s:906    .text.uart_irq_handler_sercomm:0000000000000110 $d
     /tmp/ccG8hgbC.s:913    .text.uart_poll:0000000000000000 $a
     /tmp/ccG8hgbC.s:916    .text.uart_poll:0000000000000000 uart_poll
     /tmp/ccG8hgbC.s:941    .text.uart_baudrate:0000000000000000 $a
     /tmp/ccG8hgbC.s:944    .text.uart_baudrate:0000000000000000 uart_baudrate
     /tmp/ccG8hgbC.s:1005   .text.uart_baudrate:0000000000000060 $d
     /tmp/ccG8hgbC.s:1011   .rodata:0000000000000000 $d
     /tmp/ccG8hgbC.s:1015   .rodata:0000000000000000 CSWTCH.12
     /tmp/ccG8hgbC.s:1021   .rodata:0000000000000004 uart2irq
     /tmp/ccG8hgbC.s:1027   .rodata:0000000000000008 divider
     /tmp/ccG8hgbC.s:1056   .bss:0000000000000000 old_lcr
     /tmp/ccG8hgbC.s:1057   .bss:0000000000000000 $d
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
cons_rb_flush
cons_init
irq_register_handler
irq_config
irq_enable
sercomm_init
puts
sercomm_drv_rx_char
sercomm_drv_pull
