   1              		.file	"prim_pm.c"
   9              	.Ltext0:
  10              		.cfi_sections	.debug_frame
  11              		.section	.text.l1s_neigh_pm_resp,"ax",%progbits
  12              		.align	2
  14              	l1s_neigh_pm_resp:
  15              	.LFB64:
  16              		.file 1 "layer1/prim_pm.c"
   1:layer1/prim_pm.c **** /* Layer 1 Power Measurement */
   2:layer1/prim_pm.c **** 
   3:layer1/prim_pm.c **** /* (C) 2010 by Harald Welte <laforge@gnumonks.org>
   4:layer1/prim_pm.c ****  *
   5:layer1/prim_pm.c ****  * All Rights Reserved
   6:layer1/prim_pm.c ****  *
   7:layer1/prim_pm.c ****  * This program is free software; you can redistribute it and/or modify
   8:layer1/prim_pm.c ****  * it under the terms of the GNU General Public License as published by
   9:layer1/prim_pm.c ****  * the Free Software Foundation; either version 2 of the License, or
  10:layer1/prim_pm.c ****  * (at your option) any later version.
  11:layer1/prim_pm.c ****  *
  12:layer1/prim_pm.c ****  * This program is distributed in the hope that it will be useful,
  13:layer1/prim_pm.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:layer1/prim_pm.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:layer1/prim_pm.c ****  * GNU General Public License for more details.
  16:layer1/prim_pm.c ****  *
  17:layer1/prim_pm.c ****  * You should have received a copy of the GNU General Public License along
  18:layer1/prim_pm.c ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  19:layer1/prim_pm.c ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  20:layer1/prim_pm.c ****  *
  21:layer1/prim_pm.c ****  */
  22:layer1/prim_pm.c **** 
  23:layer1/prim_pm.c **** #include <stdint.h>
  24:layer1/prim_pm.c **** #include <stdio.h>
  25:layer1/prim_pm.c **** #include <string.h>
  26:layer1/prim_pm.c **** #include <stdlib.h>
  27:layer1/prim_pm.c **** 
  28:layer1/prim_pm.c **** #include <defines.h>
  29:layer1/prim_pm.c **** #include <debug.h>
  30:layer1/prim_pm.c **** #include <memory.h>
  31:layer1/prim_pm.c **** #include <byteorder.h>
  32:layer1/prim_pm.c **** #include <osmocom/gsm/gsm_utils.h>
  33:layer1/prim_pm.c **** #include <osmocom/core/msgb.h>
  34:layer1/prim_pm.c **** #include <calypso/dsp_api.h>
  35:layer1/prim_pm.c **** #include <calypso/irq.h>
  36:layer1/prim_pm.c **** #include <calypso/tpu.h>
  37:layer1/prim_pm.c **** #include <calypso/tsp.h>
  38:layer1/prim_pm.c **** #include <calypso/dsp.h>
  39:layer1/prim_pm.c **** #include <calypso/timer.h>
  40:layer1/prim_pm.c **** #include <comm/sercomm.h>
  41:layer1/prim_pm.c **** #include <asm/system.h>
  42:layer1/prim_pm.c **** 
  43:layer1/prim_pm.c **** #include <layer1/sync.h>
  44:layer1/prim_pm.c **** #include <layer1/agc.h>
  45:layer1/prim_pm.c **** #include <layer1/tdma_sched.h>
  46:layer1/prim_pm.c **** #include <layer1/tpu_window.h>
  47:layer1/prim_pm.c **** #include <layer1/l23_api.h>
  48:layer1/prim_pm.c **** #include <layer1/prim.h>
  49:layer1/prim_pm.c **** #include <rffe.h>
  50:layer1/prim_pm.c **** 
  51:layer1/prim_pm.c **** #include <l1ctl_proto.h>
  52:layer1/prim_pm.c **** 
  53:layer1/prim_pm.c **** static void l1ddsp_meas_read(uint8_t nbmeas, uint16_t *pm)
  54:layer1/prim_pm.c **** {
  55:layer1/prim_pm.c **** 	uint8_t i;
  56:layer1/prim_pm.c **** 
  57:layer1/prim_pm.c **** 	for (i = 0; i < nbmeas; i++)
  58:layer1/prim_pm.c **** 		pm[i] = (uint16_t) ((dsp_api.db_r->a_pm[i] & 0xffff) >> 3);
  59:layer1/prim_pm.c **** 	dsp_api.r_page_used = 1;
  60:layer1/prim_pm.c **** }
  61:layer1/prim_pm.c **** 
  62:layer1/prim_pm.c **** /* scheduler callback to issue a power measurement task to the DSP */
  63:layer1/prim_pm.c **** static int l1s_pm_cmd(uint8_t num_meas,
  64:layer1/prim_pm.c **** 		      __unused uint8_t p2, uint16_t arfcn)
  65:layer1/prim_pm.c **** {
  66:layer1/prim_pm.c **** 	putchart('P');
  67:layer1/prim_pm.c **** 
  68:layer1/prim_pm.c **** 	dsp_api.db_w->d_task_md = num_meas; /* number of measurements */
  69:layer1/prim_pm.c **** 	dsp_api.ndb->d_fb_mode = 0; /* wideband search */
  70:layer1/prim_pm.c **** 
  71:layer1/prim_pm.c **** 	/* Tell the RF frontend to set the gain appropriately */
  72:layer1/prim_pm.c **** 	rffe_compute_gain(-85, CAL_DSP_TGT_BB_LVL);
  73:layer1/prim_pm.c **** 
  74:layer1/prim_pm.c **** 	/* Program TPU */
  75:layer1/prim_pm.c **** 	/* FIXME: RXWIN_PW needs to set up multiple times in case
  76:layer1/prim_pm.c **** 	 * num_meas > 1 */
  77:layer1/prim_pm.c **** 	l1s_rx_win_ctrl(arfcn, L1_RXWIN_PW, 0);
  78:layer1/prim_pm.c **** 	//l1s_rx_win_ctrl(arfcn, L1_RXWIN_NB);
  79:layer1/prim_pm.c **** 
  80:layer1/prim_pm.c **** 	return 0;
  81:layer1/prim_pm.c **** }
  82:layer1/prim_pm.c **** 
  83:layer1/prim_pm.c **** /* scheduler callback to read power measurement resposnse from the DSP */
  84:layer1/prim_pm.c **** static int l1s_pm_resp(uint8_t num_meas, __unused uint8_t p2,
  85:layer1/prim_pm.c **** 		       uint16_t arfcn)
  86:layer1/prim_pm.c **** {
  87:layer1/prim_pm.c **** 	struct l1ctl_pm_conf *pmr;
  88:layer1/prim_pm.c **** 	uint16_t pm_level[2];
  89:layer1/prim_pm.c **** 
  90:layer1/prim_pm.c **** 	putchart('p');
  91:layer1/prim_pm.c **** 
  92:layer1/prim_pm.c **** 	l1ddsp_meas_read(num_meas, pm_level);
  93:layer1/prim_pm.c **** 
  94:layer1/prim_pm.c **** 	printf("PM MEAS: ARFCN=%u, %-4d dBm at baseband, %-4d dBm at RF\n",
  95:layer1/prim_pm.c **** 		arfcn, pm_level[0]/8, agc_inp_dbm8_by_pm(pm_level[0])/8);
  96:layer1/prim_pm.c **** 
  97:layer1/prim_pm.c **** 	printd("PM MEAS: %-4d dBm, %-4d dBm ARFCN=%u\n",
  98:layer1/prim_pm.c **** 		agc_inp_dbm8_by_pm(pm_level[0])/8,
  99:layer1/prim_pm.c **** 		agc_inp_dbm8_by_pm(pm_level[1])/8, arfcn);
 100:layer1/prim_pm.c **** 
 101:layer1/prim_pm.c **** 	if (!l1s.pm.msg)
 102:layer1/prim_pm.c **** 		l1s.pm.msg = l1ctl_msgb_alloc(L1CTL_PM_CONF);
 103:layer1/prim_pm.c **** 
 104:layer1/prim_pm.c **** 	if (msgb_tailroom(l1s.pm.msg) < sizeof(*pmr)) {
 105:layer1/prim_pm.c **** 		/* flush current msgb */
 106:layer1/prim_pm.c **** 		l1_queue_for_l2(l1s.pm.msg);
 107:layer1/prim_pm.c **** 		/* allocate a new msgb and initialize header */
 108:layer1/prim_pm.c **** 		l1s.pm.msg = l1ctl_msgb_alloc(L1CTL_PM_CONF);
 109:layer1/prim_pm.c **** 	}
 110:layer1/prim_pm.c **** 
 111:layer1/prim_pm.c **** 	pmr = msgb_put(l1s.pm.msg, sizeof(*pmr));
 112:layer1/prim_pm.c **** 	pmr->band_arfcn = htons(arfcn);
 113:layer1/prim_pm.c **** 	/* FIXME: do this as RxLev rather than DBM8 ? */
 114:layer1/prim_pm.c **** 	pmr->pm[0] = dbm2rxlev(agc_inp_dbm8_by_pm(pm_level[0])/8);
 115:layer1/prim_pm.c **** 	if (num_meas > 1)
 116:layer1/prim_pm.c **** 		pmr->pm[1] = dbm2rxlev(agc_inp_dbm8_by_pm(pm_level[1])/8);
 117:layer1/prim_pm.c **** 	else
 118:layer1/prim_pm.c **** 		pmr->pm[1] = 0;
 119:layer1/prim_pm.c **** 
 120:layer1/prim_pm.c **** 	if (l1s.pm.mode == 1) {
 121:layer1/prim_pm.c **** 		if (l1s.pm.range.arfcn_next <= l1s.pm.range.arfcn_end) {
 122:layer1/prim_pm.c **** 			/* schedule PM for next ARFCN in range */
 123:layer1/prim_pm.c **** 			l1s_pm_test(1, l1s.pm.range.arfcn_next);
 124:layer1/prim_pm.c **** 			l1s.pm.range.arfcn_next++;
 125:layer1/prim_pm.c **** 		} else {
 126:layer1/prim_pm.c **** 			/* we have finished, flush the msgb to L2 */
 127:layer1/prim_pm.c **** 			struct l1ctl_hdr *l1h = l1s.pm.msg->l1h;
 128:layer1/prim_pm.c **** 			l1h->flags |= L1CTL_F_DONE;
 129:layer1/prim_pm.c **** 			l1_queue_for_l2(l1s.pm.msg);
 130:layer1/prim_pm.c **** 			l1s.pm.msg = NULL;
 131:layer1/prim_pm.c **** 		}
 132:layer1/prim_pm.c **** 	}
 133:layer1/prim_pm.c **** 
 134:layer1/prim_pm.c **** 	return 0;
 135:layer1/prim_pm.c **** }
 136:layer1/prim_pm.c **** 
 137:layer1/prim_pm.c **** static const struct tdma_sched_item pm_sched_set[] = {
 138:layer1/prim_pm.c **** 	SCHED_ITEM_DT(l1s_pm_cmd, 0, 1, 0),	SCHED_END_FRAME(),
 139:layer1/prim_pm.c **** 						SCHED_END_FRAME(),
 140:layer1/prim_pm.c **** 	SCHED_ITEM(l1s_pm_resp, -4, 1, 0),	SCHED_END_FRAME(),
 141:layer1/prim_pm.c **** 	SCHED_END_SET()
 142:layer1/prim_pm.c **** };
 143:layer1/prim_pm.c **** 
 144:layer1/prim_pm.c **** /* Schedule a power measurement test */
 145:layer1/prim_pm.c **** void l1s_pm_test(uint8_t base_fn, uint16_t arfcn)
 146:layer1/prim_pm.c **** {
 147:layer1/prim_pm.c **** 	unsigned long flags;
 148:layer1/prim_pm.c **** 
 149:layer1/prim_pm.c **** 	printd("l1s_pm_test(%u, %u)\n", base_fn, arfcn);
 150:layer1/prim_pm.c **** 
 151:layer1/prim_pm.c **** 	local_firq_save(flags);
 152:layer1/prim_pm.c **** 	tdma_schedule_set(base_fn, pm_sched_set, arfcn);
 153:layer1/prim_pm.c **** 	local_irq_restore(flags);
 154:layer1/prim_pm.c **** }
 155:layer1/prim_pm.c **** 
 156:layer1/prim_pm.c **** /*
 157:layer1/prim_pm.c ****  * perform measurements of neighbour cells
 158:layer1/prim_pm.c ****  */
 159:layer1/prim_pm.c **** 
 160:layer1/prim_pm.c **** /* scheduler callback to issue a power measurement task to the DSP */
 161:layer1/prim_pm.c **** static int l1s_neigh_pm_cmd(uint8_t num_meas,
 162:layer1/prim_pm.c **** 		      __unused uint8_t p2, __unused uint16_t p3)
 163:layer1/prim_pm.c **** {
 164:layer1/prim_pm.c **** 	uint8_t last_gain = rffe_get_gain();
 165:layer1/prim_pm.c **** 
 166:layer1/prim_pm.c **** 	dsp_api.db_w->d_task_md = num_meas; /* number of measurements */
 167:layer1/prim_pm.c **** //	dsp_api.ndb->d_fb_mode = 0; /* wideband search */
 168:layer1/prim_pm.c **** 
 169:layer1/prim_pm.c **** 	/* Tell the RF frontend to set the gain appropriately (keep last) */
 170:layer1/prim_pm.c **** 	rffe_compute_gain(-85, CAL_DSP_TGT_BB_LVL);
 171:layer1/prim_pm.c **** 
 172:layer1/prim_pm.c **** 	/* Program TPU */
 173:layer1/prim_pm.c **** 	/* FIXME: RXWIN_PW needs to set up multiple times in case
 174:layer1/prim_pm.c **** 	 * num_meas > 1 */
 175:layer1/prim_pm.c **** 	/* do measurement dummy, in case l1s.neigh_pm.n == 0 */
 176:layer1/prim_pm.c **** 	l1s_rx_win_ctrl((l1s.neigh_pm.n) ?
 177:layer1/prim_pm.c **** 		l1s.neigh_pm.band_arfcn[l1s.neigh_pm.pos] : 0, L1_RXWIN_PW, 0);
 178:layer1/prim_pm.c **** 
 179:layer1/prim_pm.c **** 	/* restore last gain */
 180:layer1/prim_pm.c **** 	rffe_set_gain(last_gain);
 181:layer1/prim_pm.c **** 
 182:layer1/prim_pm.c **** 	l1s.neigh_pm.running = 1;
 183:layer1/prim_pm.c **** 
 184:layer1/prim_pm.c **** 	return 0;
 185:layer1/prim_pm.c **** }
 186:layer1/prim_pm.c **** 
 187:layer1/prim_pm.c **** /* scheduler callback to read power measurement resposnse from the DSP */
 188:layer1/prim_pm.c **** static int l1s_neigh_pm_resp(__unused uint8_t p1, __unused uint8_t p2,
 189:layer1/prim_pm.c **** 		       __unused uint16_t p3)
 190:layer1/prim_pm.c **** {
  17              		.loc 1 190 0
  18              		.cfi_startproc
  19              		@ args = 0, pretend = 0, frame = 0
  20              		@ frame_needed = 0, uses_anonymous_args = 0
  21              	.LVL0:
  22 0000 F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
  23              	.LCFI0:
  24              		.cfi_def_cfa_offset 28
 191:layer1/prim_pm.c **** 	uint16_t dbm;
 192:layer1/prim_pm.c **** 	uint8_t level;
 193:layer1/prim_pm.c **** 
 194:layer1/prim_pm.c **** 	dsp_api.r_page_used = 1;
  25              		.loc 1 194 0
  26 0004 50319FE5 		ldr	r3, .L7
 195:layer1/prim_pm.c **** 
 196:layer1/prim_pm.c **** 	if (l1s.neigh_pm.n == 0 || !l1s.neigh_pm.running)
  27              		.loc 1 196 0
  28 0008 50819FE5 		ldr	r8, .L7+4
  29              		.cfi_offset 14, -4
  30              		.cfi_offset 10, -8
  31              		.cfi_offset 8, -12
  32              		.cfi_offset 7, -16
  33              		.cfi_offset 6, -20
  34              		.cfi_offset 5, -24
  35              		.cfi_offset 4, -28
 194:layer1/prim_pm.c **** 	dsp_api.r_page_used = 1;
  36              		.loc 1 194 0
  37 000c 0120A0E3 		mov	r2, #1
  38              	.LVL1:
  39 0010 182083E5 		str	r2, [r3, #24]
  40              		.loc 1 196 0
  41 0014 1C2CD8E5 		ldrb	r2, [r8, #3100]	@ zero_extendqisi2
  42 0018 000052E3 		cmp	r2, #0
  43 001c 4A00000A 		beq	.L2
  44              		.loc 1 196 0 is_stmt 0 discriminator 1
  45 0020 1F2CD8E5 		ldrb	r2, [r8, #3103]	@ zero_extendqisi2
  46 0024 000052E3 		cmp	r2, #0
  47 0028 4700000A 		beq	.L2
  48              	.LVL2:
 197:layer1/prim_pm.c **** 		goto out;
 198:layer1/prim_pm.c **** 
 199:layer1/prim_pm.c **** 	dbm = (uint16_t) ((dsp_api.db_r->a_pm[0] & 0xffff) >> 3);
  49              		.loc 1 199 0 is_stmt 1
  50 002c 043093E5 		ldr	r3, [r3, #4]
  51 0030 B801D3E1 		ldrh	r0, [r3, #24]
  52              	.LVL3:
 200:layer1/prim_pm.c **** 	level = dbm2rxlev(agc_inp_dbm8_by_pm(dbm)/8);
  53              		.loc 1 200 0
  54 0034 A001A0E1 		mov	r0, r0, lsr #3
  55 0038 FEFFFFEB 		bl	agc_inp_dbm8_by_pm
  56              	.LVL4:
  57 003c 0008A0E1 		mov	r0, r0, asl #16
  58 0040 4008A0E1 		mov	r0, r0, asr #16
  59 0044 073080E2 		add	r3, r0, #7
  60 0048 000050E3 		cmp	r0, #0
  61 004c 0300A0B1 		movlt	r0, r3
  62 0050 C001A0E1 		mov	r0, r0, asr #3
  63 0054 FEFFFFEB 		bl	dbm2rxlev
  64              	.LVL5:
 201:layer1/prim_pm.c **** 
 202:layer1/prim_pm.c **** 	l1s.neigh_pm.level[l1s.neigh_pm.pos] = level;
  65              		.loc 1 202 0
  66 0058 1E3CD8E5 		ldrb	r3, [r8, #3102]	@ zero_extendqisi2
  67 005c 032088E0 		add	r2, r8, r3
  68 0060 A00CC2E5 		strb	r0, [r2, #3232]
 203:layer1/prim_pm.c **** 
 204:layer1/prim_pm.c **** 	if (++l1s.neigh_pm.pos >= l1s.neigh_pm.n) {
  69              		.loc 1 204 0
  70 0064 013083E2 		add	r3, r3, #1
  71 0068 1C2CD8E5 		ldrb	r2, [r8, #3100]	@ zero_extendqisi2
  72 006c FF3003E2 		and	r3, r3, #255
  73 0070 030052E1 		cmp	r2, r3
  74 0074 1E3CC8E5 		strb	r3, [r8, #3102]
  75 0078 3300008A 		bhi	.L2
  76              	.LBB30:
 205:layer1/prim_pm.c **** 		struct msgb *msg;
 206:layer1/prim_pm.c **** 		struct l1ctl_neigh_pm_ind *mi;
 207:layer1/prim_pm.c **** 		int i;
 208:layer1/prim_pm.c **** 
 209:layer1/prim_pm.c **** 		l1s.neigh_pm.pos = 0;
  77              		.loc 1 209 0
  78 007c 0050A0E3 		mov	r5, #0
 210:layer1/prim_pm.c **** 		/* return result */
 211:layer1/prim_pm.c **** 		msg = l1ctl_msgb_alloc(L1CTL_NEIGH_PM_IND);
  79              		.loc 1 211 0
  80 0080 1B00A0E3 		mov	r0, #27
  81              	.LVL6:
 209:layer1/prim_pm.c **** 		l1s.neigh_pm.pos = 0;
  82              		.loc 1 209 0
  83 0084 1E5CC8E5 		strb	r5, [r8, #3102]
  84              		.loc 1 211 0
  85 0088 FEFFFFEB 		bl	l1ctl_msgb_alloc
  86 008c D0709FE5 		ldr	r7, .L7+8
  87 0090 0040A0E1 		mov	r4, r0
  88              	.LVL7:
 212:layer1/prim_pm.c **** 		for (i = 0; i < l1s.neigh_pm.n; i++) {
 213:layer1/prim_pm.c **** 			if (msgb_tailroom(msg) < (int) sizeof(*mi)) {
 214:layer1/prim_pm.c **** 				l1_queue_for_l2(msg);
 215:layer1/prim_pm.c **** 				msg = l1ctl_msgb_alloc(L1CTL_NEIGH_PM_IND);
 216:layer1/prim_pm.c **** 			}
 217:layer1/prim_pm.c **** 			mi = (struct l1ctl_neigh_pm_ind *)
 218:layer1/prim_pm.c **** 				msgb_put(msg, sizeof(*mi));
 219:layer1/prim_pm.c **** 			mi->band_arfcn = htons(l1s.neigh_pm.band_arfcn[i]);
  89              		.loc 1 219 0
  90 0094 05A0A0E1 		mov	sl, r5
 212:layer1/prim_pm.c **** 		for (i = 0; i < l1s.neigh_pm.n; i++) {
  91              		.loc 1 212 0
  92 0098 260000EA 		b	.L3
  93              	.LVL8:
  94              	.L6:
  95              	.LBB31:
  96              	.LBB32:
  97              		.file 2 "../../shared/libosmocore/include/osmocom/core/msgb.h"
   1:../../shared/libosmocore/include/osmocom/core/msgb.h **** #ifndef _MSGB_H
   2:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define _MSGB_H
   3:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
   4:../../shared/libosmocore/include/osmocom/core/msgb.h **** /* (C) 2008 by Harald Welte <laforge@gnumonks.org>
   5:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * All Rights Reserved
   6:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
   7:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This program is free software; you can redistribute it and/or modify
   8:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * it under the terms of the GNU General Public License as published by
   9:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * the Free Software Foundation; either version 2 of the License, or
  10:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * (at your option) any later version.
  11:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  12:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This program is distributed in the hope that it will be useful,
  13:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * GNU General Public License for more details.
  16:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  17:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * You should have received a copy of the GNU General Public License along
  18:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  19:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  20:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  21:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  22:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  23:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <stdint.h>
  24:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/linuxlist.h>
  25:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/utils.h>
  26:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  27:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \defgroup msgb Message buffers
  28:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  @{
  29:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  30:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  31:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \file msgb.h
  32:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \brief Osmocom message buffers
  33:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The Osmocom message buffers are modelled after the 'struct skb'
  34:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * inside the Linux kernel network stack.  As they exist in userspace,
  35:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * they are much simplified.  However, terminology such as headroom,
  36:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * tailroom, push/pull/put etc. remains the same.
  37:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  38:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  39:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_DEBUG
  40:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  41:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Osmocom message buffer */
  42:../../shared/libosmocore/include/osmocom/core/msgb.h **** struct msgb {
  43:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct llist_head list; /*!< \brief linked list header */
  44:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  45:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  46:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	/* Part of which TRX logical channel we were received / transmitted */
  47:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	/* FIXME: move them into the control buffer */
  48:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	union {
  49:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		void *dst; /*!< \brief reference of origin/destination */
  50:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		struct gsm_bts_trx *trx;
  51:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	};
  52:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct gsm_lchan *lchan; /*!< \brief logical channel */
  53:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  54:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l1h; /*!< \brief pointer to Layer1 header (if any) */
  55:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l2h; /*!< \brief pointer to A-bis layer 2 header: OML, RSL(RLL), NS */
  56:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l3h; /*!< \brief pointer to Layer 3 header. For OML: FOM; RSL: 04.08; GPRS: BSSGP *
  57:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l4h; /*!< \brief pointer to layer 4 header */
  58:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  59:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned long cb[5]; /*!< \brief control buffer */
  60:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  61:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint16_t data_len;   /*!< \brief length of underlying data array */
  62:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint16_t len;	     /*!< \brief length of bytes used in msgb */
  63:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  64:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *head;	/*!< \brief start of underlying memory buffer */
  65:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tail;	/*!< \brief end of message in buffer */
  66:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *data;	/*!< \brief start of message in buffer */
  67:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char _data[0]; /*!< \brief optional immediate data array */
  68:../../shared/libosmocore/include/osmocom/core/msgb.h **** };
  69:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  70:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern struct msgb *msgb_alloc(uint16_t size, const char *name);
  71:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_free(struct msgb *m);
  72:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_enqueue(struct llist_head *queue, struct msgb *msg);
  73:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern struct msgb *msgb_dequeue(struct llist_head *queue);
  74:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_reset(struct msgb *m);
  75:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  76:../../shared/libosmocore/include/osmocom/core/msgb.h **** #ifdef MSGB_DEBUG
  77:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/panic.h>
  78:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_ABORT(msg, fmt, args ...) do {		\
  79:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	osmo_panic("msgb(%p): " fmt, msg, ## args);	\
  80:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	} while(0)
  81:../../shared/libosmocore/include/osmocom/core/msgb.h **** #else
  82:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_ABORT(msg, fmt, args ...)
  83:../../shared/libosmocore/include/osmocom/core/msgb.h **** #endif
  84:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  85:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L1 header of msgb */
  86:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l1(m)	((void *)(m->l1h))
  87:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L2 header of msgb */
  88:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l2(m)	((void *)(m->l2h))
  89:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L3 header of msgb */
  90:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l3(m)	((void *)(m->l3h))
  91:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain SMS header of msgb */
  92:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_sms(m)	((void *)(m->l4h))
  93:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  94:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L1 message
  95:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
  96:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L1 message in bytes
  97:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  98:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
  99:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 1 header.
 100:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 101:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l1len(const struct msgb *msgb)
 102:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 103:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l1(msgb);
 104:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 105:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 106:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L2 message
 107:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 108:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L2 message in bytes
 109:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 110:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 111:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 2 header.
 112:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 113:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l2len(const struct msgb *msgb)
 114:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 115:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l2(msgb);
 116:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 117:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 118:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L3 message
 119:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 120:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L3 message in bytes
 121:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 122:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 123:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 3 header.
 124:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 125:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l3len(const struct msgb *msgb)
 126:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 127:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l3(msgb);
 128:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 129:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 130:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine the length of the header
 131:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 132:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes between start of buffer and start of msg
 133:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 134:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the length difference between the underlying
 135:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer and the used section of the \a msgb.
 136:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 137:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_headlen(const struct msgb *msgb)
 138:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 139:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->len - msgb->data_len;
 140:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 141:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 142:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine how much tail room is left in msgb
 143:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 144:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes remaining at end of msgb
 145:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 146:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the amount of octets left in the underlying
 147:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer after the end of the message.
 148:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 149:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_tailroom(const struct msgb *msgb)
 150:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 151:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->head + msgb->data_len) - msgb->tail;
  98              		.loc 2 151 0
  99 009c 382094E5 		ldr	r2, [r4, #56]
 100 00a0 B433D4E1 		ldrh	r3, [r4, #52]
 101 00a4 033082E0 		add	r3, r2, r3
 102 00a8 3C2094E5 		ldr	r2, [r4, #60]
 103 00ac 033062E0 		rsb	r3, r2, r3
 104              	.LBE32:
 105              	.LBE31:
 213:layer1/prim_pm.c **** 			if (msgb_tailroom(msg) < (int) sizeof(*mi)) {
 106              		.loc 1 213 0
 107 00b0 030053E3 		cmp	r3, #3
 108 00b4 040000CA 		bgt	.L4
 214:layer1/prim_pm.c **** 				l1_queue_for_l2(msg);
 109              		.loc 1 214 0
 110 00b8 0400A0E1 		mov	r0, r4
 111 00bc FEFFFFEB 		bl	l1_queue_for_l2
 215:layer1/prim_pm.c **** 				msg = l1ctl_msgb_alloc(L1CTL_NEIGH_PM_IND);
 112              		.loc 1 215 0
 113 00c0 1B00A0E3 		mov	r0, #27
 114 00c4 FEFFFFEB 		bl	l1ctl_msgb_alloc
 115 00c8 0040A0E1 		mov	r4, r0
 116              	.LVL9:
 117              	.L4:
 118              	.LBB33:
 119              	.LBB34:
 120              	.LBB35:
 121              	.LBB36:
 122              		.loc 2 151 0
 123 00cc B433D4E1 		ldrh	r3, [r4, #52]
 124              	.LBE36:
 125              	.LBE35:
 126 00d0 382084E2 		add	r2, r4, #56
 127 00d4 440092E8 		ldmia	r2, {r2, r6}	@ phole ldm
 128              	.LVL10:
 129              	.LBB38:
 130              	.LBB37:
 131 00d8 032082E0 		add	r2, r2, r3
 132 00dc 022066E0 		rsb	r2, r6, r2
 133              	.LBE37:
 134              	.LBE38:
 152:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 153:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 154:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine the amount of headroom in msgb
 155:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 156:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes left ahead of message start in msgb
 157:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 158:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the amount of bytes left in the underlying
 159:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer before the start of the actual message.
 160:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 161:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_headroom(const struct msgb *msgb)
 162:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 163:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->data - msgb->head);
 164:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 165:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 166:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append data to end of message buffer
 167:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 168:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of bytes to append to message
 169:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns pointer to start of newly-appended data
 170:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 171:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function will move the \a tail pointer of the message buffer \a
 172:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * len bytes further, thus enlarging the message by \a len bytes.
 173:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 174:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The return value is a pointer to start of the newly added section at
 175:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * the end of the message and can be used for actually filling/copying
 176:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data into it.
 177:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 178:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_put(struct msgb *msgb, unsigned int len)
 179:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 180:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tmp = msgb->tail;
 181:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_tailroom(msgb) < (int) len)
 135              		.loc 2 181 0
 136 00e0 030052E3 		cmp	r2, #3
 137              	.LVL11:
 182:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "Not enough tailroom msgb_push (%u < %u)\n",
 138              		.loc 2 182 0
 139 00e4 7C009FD5 		ldrle	r0, .L7+12
 140 00e8 0410A0D1 		movle	r1, r4
 141 00ec 0430A0D3 		movle	r3, #4
 142 00f0 FEFFFFDB 		blle	osmo_panic
 143              	.LVL12:
 144              	.L5:
 183:../../shared/libosmocore/include/osmocom/core/msgb.h **** 			   msgb_tailroom(msgb), len);
 184:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->tail += len;
 145              		.loc 2 184 0
 146 00f4 3C3094E5 		ldr	r3, [r4, #60]
 147 00f8 043083E2 		add	r3, r3, #4
 148 00fc 3C3084E5 		str	r3, [r4, #60]
 185:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len += len;
 149              		.loc 2 185 0
 150 0100 B633D4E1 		ldrh	r3, [r4, #54]
 151 0104 043083E2 		add	r3, r3, #4
 152 0108 B633C4E1 		strh	r3, [r4, #54]	@ movhi
 153              	.LVL13:
 154              	.LBE34:
 155              	.LBE33:
 156              		.loc 1 219 0
 157 010c B230F7E1 		ldrh	r3, [r7, #2]!
 158              	.LVL14:
 159              	.LBB39:
 160              	.LBB40:
 161              		.file 3 "include/swab.h"
   1:include/swab.h **** #ifndef _LINUX_SWAB_H
   2:include/swab.h **** #define _LINUX_SWAB_H
   3:include/swab.h **** 
   4:include/swab.h **** #include <stdint.h>
   5:include/swab.h **** #include <defines.h>
   6:include/swab.h **** #include <asm/swab.h>
   7:include/swab.h **** 
   8:include/swab.h **** /*
   9:include/swab.h ****  * casts are necessary for constants, because we never know how for sure
  10:include/swab.h ****  * how U/UL/ULL map to uint16_t, uint32_t, uint64_t. At least not in a portable way.
  11:include/swab.h ****  */
  12:include/swab.h **** #define ___constant_swab16(x) ((uint16_t)(				\
  13:include/swab.h **** 	(((uint16_t)(x) & (uint16_t)0x00ffU) << 8) |			\
  14:include/swab.h **** 	(((uint16_t)(x) & (uint16_t)0xff00U) >> 8)))
  15:include/swab.h **** 
  16:include/swab.h **** #define ___constant_swab32(x) ((uint32_t)(				\
  17:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x000000ffUL) << 24) |		\
  18:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x0000ff00UL) <<  8) |		\
  19:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x00ff0000UL) >>  8) |		\
  20:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xff000000UL) >> 24)))
  21:include/swab.h **** 
  22:include/swab.h **** #define ___constant_swab64(x) ((uint64_t)(				\
  23:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00000000000000ffULL) << 56) |	\
  24:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x000000000000ff00ULL) << 40) |	\
  25:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x0000000000ff0000ULL) << 24) |	\
  26:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00000000ff000000ULL) <<  8) |	\
  27:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x000000ff00000000ULL) >>  8) |	\
  28:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x0000ff0000000000ULL) >> 24) |	\
  29:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00ff000000000000ULL) >> 40) |	\
  30:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0xff00000000000000ULL) >> 56)))
  31:include/swab.h **** 
  32:include/swab.h **** #define ___constant_swahw32(x) ((uint32_t)(			\
  33:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x0000ffffUL) << 16) |		\
  34:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xffff0000UL) >> 16)))
  35:include/swab.h **** 
  36:include/swab.h **** #define ___constant_swahb32(x) ((uint32_t)(			\
  37:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x00ff00ffUL) << 8) |		\
  38:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xff00ff00UL) >> 8)))
  39:include/swab.h **** 
  40:include/swab.h **** /*
  41:include/swab.h ****  * Implement the following as inlines, but define the interface using
  42:include/swab.h ****  * macros to allow constant folding when possible:
  43:include/swab.h ****  * ___swab16, ___swab32, ___swab64, ___swahw32, ___swahb32
  44:include/swab.h ****  */
  45:include/swab.h **** 
  46:include/swab.h **** static inline __attribute_const__ uint16_t __fswab16(uint16_t val)
  47:include/swab.h **** {
  48:include/swab.h **** #ifdef __arch_swab16
  49:include/swab.h **** 	return __arch_swab16(val);
  50:include/swab.h **** #else
  51:include/swab.h **** 	return ___constant_swab16(val);
 162              		.loc 3 51 0
 163 0110 2324A0E1 		mov	r2, r3, lsr #8
 164 0114 033482E1 		orr	r3, r2, r3, asl #8
 165              	.LVL15:
 166              	.LBE40:
 167              	.LBE39:
 168              		.loc 1 219 0
 169 0118 0030C6E5 		strb	r3, [r6, #0]
 170 011c 2334A0E1 		mov	r3, r3, lsr #8
 171 0120 0130C6E5 		strb	r3, [r6, #1]
 188:layer1/prim_pm.c **** static int l1s_neigh_pm_resp(__unused uint8_t p1, __unused uint8_t p2,
 172              		.loc 1 188 0
 173 0124 083085E0 		add	r3, r5, r8
 220:layer1/prim_pm.c **** 			mi->pm[0] = l1s.neigh_pm.level[i];
 174              		.loc 1 220 0
 175 0128 A03CD3E5 		ldrb	r3, [r3, #3232]	@ zero_extendqisi2
 221:layer1/prim_pm.c **** 			mi->pm[1] = 0;
 176              		.loc 1 221 0
 177 012c 03A0C6E5 		strb	sl, [r6, #3]
 220:layer1/prim_pm.c **** 			mi->pm[0] = l1s.neigh_pm.level[i];
 178              		.loc 1 220 0
 179 0130 0230C6E5 		strb	r3, [r6, #2]
 212:layer1/prim_pm.c **** 		for (i = 0; i < l1s.neigh_pm.n; i++) {
 180              		.loc 1 212 0
 181 0134 015085E2 		add	r5, r5, #1
 182              	.LVL16:
 183              	.L3:
 212:layer1/prim_pm.c **** 		for (i = 0; i < l1s.neigh_pm.n; i++) {
 184              		.loc 1 212 0 is_stmt 0 discriminator 1
 185 0138 1C3CD8E5 		ldrb	r3, [r8, #3100]	@ zero_extendqisi2
 186 013c 030055E1 		cmp	r5, r3
 187 0140 D5FFFFBA 		blt	.L6
 222:layer1/prim_pm.c **** 		}
 223:layer1/prim_pm.c **** 		l1_queue_for_l2(msg);
 188              		.loc 1 223 0 is_stmt 1
 189 0144 0400A0E1 		mov	r0, r4
 190 0148 FEFFFFEB 		bl	l1_queue_for_l2
 191              	.LVL17:
 192              	.L2:
 193              	.LBE30:
 224:layer1/prim_pm.c **** 	}
 225:layer1/prim_pm.c **** 
 226:layer1/prim_pm.c **** out:
 227:layer1/prim_pm.c **** 	l1s.neigh_pm.running = 0;
 194              		.loc 1 227 0
 195 014c 0C309FE5 		ldr	r3, .L7+4
 196 0150 0000A0E3 		mov	r0, #0
 197 0154 1F0CC3E5 		strb	r0, [r3, #3103]
 228:layer1/prim_pm.c **** 
 229:layer1/prim_pm.c **** 	return 0;
 230:layer1/prim_pm.c **** }
 198              		.loc 1 230 0
 199 0158 F085BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, sl, pc}
 200              	.L8:
 201              		.align	2
 202              	.L7:
 203 015c 00000000 		.word	dsp_api
 204 0160 00000000 		.word	l1s
 205 0164 1E0C0000 		.word	l1s+3102
 206 0168 00000000 		.word	.LC0
 207              		.cfi_endproc
 208              	.LFE64:
 210              		.section	.text.l1s_pm_cmd,"ax",%progbits
 211              		.align	2
 213              	l1s_pm_cmd:
 214              	.LFB60:
  65:layer1/prim_pm.c **** {
 215              		.loc 1 65 0
 216              		.cfi_startproc
 217              		@ args = 0, pretend = 0, frame = 0
 218              		@ frame_needed = 0, uses_anonymous_args = 0
 219              	.LVL18:
  68:layer1/prim_pm.c **** 	dsp_api.db_w->d_task_md = num_meas; /* number of measurements */
 220              		.loc 1 68 0
 221 0000 44309FE5 		ldr	r3, .L10
  65:layer1/prim_pm.c **** {
 222              		.loc 1 65 0
 223 0004 0228A0E1 		mov	r2, r2, asl #16
 224              	.LVL19:
 225 0008 30402DE9 		stmfd	sp!, {r4, r5, lr}
 226              	.LCFI1:
 227              		.cfi_def_cfa_offset 12
  65:layer1/prim_pm.c **** {
 228              		.loc 1 65 0
 229 000c 2258A0E1 		mov	r5, r2, lsr #16
 230              		.cfi_offset 14, -4
 231              		.cfi_offset 5, -8
 232              		.cfi_offset 4, -12
  68:layer1/prim_pm.c **** 	dsp_api.db_w->d_task_md = num_meas; /* number of measurements */
 233              		.loc 1 68 0
 234 0010 082093E5 		ldr	r2, [r3, #8]
  69:layer1/prim_pm.c **** 	dsp_api.ndb->d_fb_mode = 0; /* wideband search */
 235              		.loc 1 69 0
 236 0014 003093E5 		ldr	r3, [r3, #0]
 237 0018 0040A0E3 		mov	r4, #0
  65:layer1/prim_pm.c **** {
 238              		.loc 1 65 0
 239 001c FF0000E2 		and	r0, r0, #255
 240              	.LVL20:
  68:layer1/prim_pm.c **** 	dsp_api.db_w->d_task_md = num_meas; /* number of measurements */
 241              		.loc 1 68 0
 242 0020 B800C2E1 		strh	r0, [r2, #8]	@ movhi
  72:layer1/prim_pm.c **** 	rffe_compute_gain(-85, CAL_DSP_TGT_BB_LVL);
 243              		.loc 1 72 0
 244 0024 5010A0E3 		mov	r1, #80
 245              	.LVL21:
  69:layer1/prim_pm.c **** 	dsp_api.ndb->d_fb_mode = 0; /* wideband search */
 246              		.loc 1 69 0
 247 0028 BA44C3E1 		strh	r4, [r3, #74]	@ movhi
  72:layer1/prim_pm.c **** 	rffe_compute_gain(-85, CAL_DSP_TGT_BB_LVL);
 248              		.loc 1 72 0
 249 002c 5400E0E3 		mvn	r0, #84
 250 0030 FEFFFFEB 		bl	rffe_compute_gain
  77:layer1/prim_pm.c **** 	l1s_rx_win_ctrl(arfcn, L1_RXWIN_PW, 0);
 251              		.loc 1 77 0
 252 0034 0500A0E1 		mov	r0, r5
 253 0038 0410A0E1 		mov	r1, r4
 254 003c 0420A0E1 		mov	r2, r4
 255 0040 FEFFFFEB 		bl	l1s_rx_win_ctrl
  81:layer1/prim_pm.c **** }
 256              		.loc 1 81 0
 257 0044 0400A0E1 		mov	r0, r4
 258 0048 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 259              	.L11:
 260              		.align	2
 261              	.L10:
 262 004c 00000000 		.word	dsp_api
 263              		.cfi_endproc
 264              	.LFE60:
 266              		.section	.text.l1s_neigh_pm_cmd,"ax",%progbits
 267              		.align	2
 269              	l1s_neigh_pm_cmd:
 270              	.LFB63:
 163:layer1/prim_pm.c **** {
 271              		.loc 1 163 0
 272              		.cfi_startproc
 273              		@ args = 0, pretend = 0, frame = 0
 274              		@ frame_needed = 0, uses_anonymous_args = 0
 275              	.LVL22:
 276 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 277              	.LCFI2:
 278              		.cfi_def_cfa_offset 12
 163:layer1/prim_pm.c **** {
 279              		.loc 1 163 0
 280 0004 FF5000E2 		and	r5, r0, #255
 281              		.cfi_offset 14, -4
 282              		.cfi_offset 5, -8
 283              		.cfi_offset 4, -12
 164:layer1/prim_pm.c **** 	uint8_t last_gain = rffe_get_gain();
 284              		.loc 1 164 0
 285 0008 FEFFFFEB 		bl	rffe_get_gain
 286              	.LVL23:
 166:layer1/prim_pm.c **** 	dsp_api.db_w->d_task_md = num_meas; /* number of measurements */
 287              		.loc 1 166 0
 288 000c 58309FE5 		ldr	r3, .L15
 289 0010 083093E5 		ldr	r3, [r3, #8]
 164:layer1/prim_pm.c **** 	uint8_t last_gain = rffe_get_gain();
 290              		.loc 1 164 0
 291 0014 0040A0E1 		mov	r4, r0
 292              	.LVL24:
 166:layer1/prim_pm.c **** 	dsp_api.db_w->d_task_md = num_meas; /* number of measurements */
 293              		.loc 1 166 0
 294 0018 B850C3E1 		strh	r5, [r3, #8]	@ movhi
 170:layer1/prim_pm.c **** 	rffe_compute_gain(-85, CAL_DSP_TGT_BB_LVL);
 295              		.loc 1 170 0
 296 001c 5400E0E3 		mvn	r0, #84
 297              	.LVL25:
 298 0020 5010A0E3 		mov	r1, #80
 299 0024 FEFFFFEB 		bl	rffe_compute_gain
 176:layer1/prim_pm.c **** 	l1s_rx_win_ctrl((l1s.neigh_pm.n) ?
 300              		.loc 1 176 0
 301 0028 40309FE5 		ldr	r3, .L15+4
 302 002c 1C0CD3E5 		ldrb	r0, [r3, #3100]	@ zero_extendqisi2
 303 0030 000050E3 		cmp	r0, #0
 177:layer1/prim_pm.c **** 		l1s.neigh_pm.band_arfcn[l1s.neigh_pm.pos] : 0, L1_RXWIN_PW, 0);
 304              		.loc 1 177 0
 305 0034 1E2CD315 		ldrneb	r2, [r3, #3102]	@ zero_extendqisi2
 306 0038 612E8212 		addne	r2, r2, #1552
 307 003c 8220A011 		movne	r2, r2, asl #1
 176:layer1/prim_pm.c **** 	l1s_rx_win_ctrl((l1s.neigh_pm.n) ?
 308              		.loc 1 176 0
 309 0040 0010A0E3 		mov	r1, #0
 310 0044 B2009311 		ldrneh	r0, [r3, r2]
 311 0048 0120A0E1 		mov	r2, r1
 312 004c FEFFFFEB 		bl	l1s_rx_win_ctrl
 180:layer1/prim_pm.c **** 	rffe_set_gain(last_gain);
 313              		.loc 1 180 0
 314 0050 0400A0E1 		mov	r0, r4
 315 0054 FEFFFFEB 		bl	rffe_set_gain
 182:layer1/prim_pm.c **** 	l1s.neigh_pm.running = 1;
 316              		.loc 1 182 0
 317 0058 10309FE5 		ldr	r3, .L15+4
 318 005c 0120A0E3 		mov	r2, #1
 319 0060 1F2CC3E5 		strb	r2, [r3, #3103]
 185:layer1/prim_pm.c **** }
 320              		.loc 1 185 0
 321 0064 0000A0E3 		mov	r0, #0
 322 0068 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 323              	.L16:
 324              		.align	2
 325              	.L15:
 326 006c 00000000 		.word	dsp_api
 327 0070 00000000 		.word	l1s
 328              		.cfi_endproc
 329              	.LFE63:
 331              		.section	.text.l1s_pm_test,"ax",%progbits
 332              		.align	2
 333              		.global	l1s_pm_test
 335              	l1s_pm_test:
 336              	.LFB62:
 146:layer1/prim_pm.c **** {
 337              		.loc 1 146 0
 338              		.cfi_startproc
 339              		@ args = 0, pretend = 0, frame = 0
 340              		@ frame_needed = 0, uses_anonymous_args = 0
 341              	.LVL26:
 342 0000 0128A0E1 		mov	r2, r1, asl #16
 343 0004 10402DE9 		stmfd	sp!, {r4, lr}
 344              	.LCFI3:
 345              		.cfi_def_cfa_offset 8
 146:layer1/prim_pm.c **** {
 346              		.loc 1 146 0
 347 0008 FF0000E2 		and	r0, r0, #255
 348              	.LVL27:
 349 000c 2228A0E1 		mov	r2, r2, lsr #16
 350              	.LBB41:
 151:layer1/prim_pm.c **** 	local_firq_save(flags);
 351              		.loc 1 151 0
 352              	@ 151 "layer1/prim_pm.c" 1
 353 0010 00400FE1 		mrs	r4, cpsr		@ local_firq_save
 354 0014 C03084E3 		orr	r3, r4, #0xC0
 355 0018 03F021E1 		msr	cpsr_c, r3
 356              	@ 0 "" 2
 357              	.LBE41:
 152:layer1/prim_pm.c **** 	tdma_schedule_set(base_fn, pm_sched_set, arfcn);
 358              		.loc 1 152 0
 359 001c 08109FE5 		ldr	r1, .L18
 360              	.LVL28:
 361              		.cfi_offset 14, -4
 362              		.cfi_offset 4, -8
 363 0020 FEFFFFEB 		bl	tdma_schedule_set
 153:layer1/prim_pm.c **** 	local_irq_restore(flags);
 364              		.loc 1 153 0
 365              	@ 153 "layer1/prim_pm.c" 1
 366 0024 04F021E1 		msr	cpsr_c, r4		@ local_irq_restore
 367              	
 368              	@ 0 "" 2
 154:layer1/prim_pm.c **** }
 369              		.loc 1 154 0
 370 0028 1080BDE8 		ldmfd	sp!, {r4, pc}
 371              	.L19:
 372              		.align	2
 373              	.L18:
 374 002c 00000000 		.word	.LANCHOR0
 375              		.cfi_endproc
 376              	.LFE62:
 378              		.section	.text.l1s_pm_resp,"ax",%progbits
 379              		.align	2
 381              	l1s_pm_resp:
 382              	.LFB61:
  86:layer1/prim_pm.c **** {
 383              		.loc 1 86 0
 384              		.cfi_startproc
 385              		@ args = 0, pretend = 0, frame = 4
 386              		@ frame_needed = 0, uses_anonymous_args = 0
 387              	.LVL29:
 388 0000 F1412DE9 		stmfd	sp!, {r0, r4, r5, r6, r7, r8, lr}
 389              	.LCFI4:
 390              		.cfi_def_cfa_offset 28
 391              	.LBB42:
 392              	.LBB44:
  58:layer1/prim_pm.c **** 		pm[i] = (uint16_t) ((dsp_api.db_r->a_pm[i] & 0xffff) >> 3);
 393              		.loc 1 58 0
 394 0004 E4319FE5 		ldr	r3, .L30
 395              	.LBE44:
 396              	.LBE42:
  86:layer1/prim_pm.c **** {
 397              		.loc 1 86 0
 398 0008 0228A0E1 		mov	r2, r2, asl #16
 399              	.LVL30:
 400 000c 2268A0E1 		mov	r6, r2, lsr #16
 401              		.cfi_offset 14, -4
 402              		.cfi_offset 8, -8
 403              		.cfi_offset 7, -12
 404              		.cfi_offset 6, -16
 405              		.cfi_offset 5, -20
 406              		.cfi_offset 4, -24
 407              		.cfi_offset 0, -28
  84:layer1/prim_pm.c **** static int l1s_pm_resp(uint8_t num_meas, __unused uint8_t p2,
 408              		.loc 1 84 0
 409 0010 042093E5 		ldr	r2, [r3, #4]
  86:layer1/prim_pm.c **** {
 410              		.loc 1 86 0
 411 0014 FF8000E2 		and	r8, r0, #255
 412              	.LVL31:
 413 0018 02304DE2 		sub	r3, sp, #2
  84:layer1/prim_pm.c **** static int l1s_pm_resp(uint8_t num_meas, __unused uint8_t p2,
 414              		.loc 1 84 0
 415 001c 162082E2 		add	r2, r2, #22
 416 0020 881083E0 		add	r1, r3, r8, asl #1
 417              	.LVL32:
 418 0024 020000EA 		b	.L21
 419              	.LVL33:
 420              	.L22:
 421              	.LBB46:
 422              	.LBB43:
  58:layer1/prim_pm.c **** 		pm[i] = (uint16_t) ((dsp_api.db_r->a_pm[i] & 0xffff) >> 3);
 423              		.loc 1 58 0
 424 0028 B200F2E1 		ldrh	r0, [r2, #2]!
 425 002c A001A0E1 		mov	r0, r0, lsr #3
 426 0030 B200E3E1 		strh	r0, [r3, #2]!	@ movhi
 427              	.L21:
  57:layer1/prim_pm.c **** 	for (i = 0; i < nbmeas; i++)
 428              		.loc 1 57 0
 429 0034 010053E1 		cmp	r3, r1
 430 0038 FAFFFF1A 		bne	.L22
  59:layer1/prim_pm.c **** 	dsp_api.r_page_used = 1;
 431              		.loc 1 59 0
 432 003c AC319FE5 		ldr	r3, .L30
 433              	.LBE43:
 434              	.LBE46:
  95:layer1/prim_pm.c **** 		arfcn, pm_level[0]/8, agc_inp_dbm8_by_pm(pm_level[0])/8);
 435              		.loc 1 95 0
 436 0040 F070DDE1 		ldrsh	r7, [sp, #0]
 437              	.LBB47:
 438              	.LBB45:
  59:layer1/prim_pm.c **** 	dsp_api.r_page_used = 1;
 439              		.loc 1 59 0
 440 0044 0120A0E3 		mov	r2, #1
 441 0048 182083E5 		str	r2, [r3, #24]
 442              	.LBE45:
 443              	.LBE47:
  95:layer1/prim_pm.c **** 		arfcn, pm_level[0]/8, agc_inp_dbm8_by_pm(pm_level[0])/8);
 444              		.loc 1 95 0
 445 004c 0700A0E1 		mov	r0, r7
 446 0050 B040DDE1 		ldrh	r4, [sp, #0]
 447 0054 FEFFFFEB 		bl	agc_inp_dbm8_by_pm
  94:layer1/prim_pm.c **** 	printf("PM MEAS: ARFCN=%u, %-4d dBm at baseband, %-4d dBm at RF\n",
 448              		.loc 1 94 0
 449 0058 0038A0E1 		mov	r3, r0, asl #16
 450 005c 4338A0E1 		mov	r3, r3, asr #16
 451 0060 000053E3 		cmp	r3, #0
 452 0064 072083E2 		add	r2, r3, #7
 453 0068 0230A0B1 		movlt	r3, r2
 454 006c A421A0E1 		mov	r2, r4, lsr #3
 101:layer1/prim_pm.c **** 	if (!l1s.pm.msg)
 455              		.loc 1 101 0
 456 0070 7C419FE5 		ldr	r4, .L30+4
  94:layer1/prim_pm.c **** 	printf("PM MEAS: ARFCN=%u, %-4d dBm at baseband, %-4d dBm at RF\n",
 457              		.loc 1 94 0
 458 0074 C331A0E1 		mov	r3, r3, asr #3
 459 0078 78019FE5 		ldr	r0, .L30+8
 460 007c 0610A0E1 		mov	r1, r6
 461 0080 FEFFFFEB 		bl	printf
 101:layer1/prim_pm.c **** 	if (!l1s.pm.msg)
 462              		.loc 1 101 0
 463 0084 003B94E5 		ldr	r3, [r4, #2816]
 464 0088 000053E3 		cmp	r3, #0
 465 008c 0200001A 		bne	.L23
 102:layer1/prim_pm.c **** 		l1s.pm.msg = l1ctl_msgb_alloc(L1CTL_PM_CONF);
 466              		.loc 1 102 0
 467 0090 0900A0E3 		mov	r0, #9
 468 0094 FEFFFFEB 		bl	l1ctl_msgb_alloc
 469 0098 000B84E5 		str	r0, [r4, #2816]
 470              	.L23:
 104:layer1/prim_pm.c **** 	if (msgb_tailroom(l1s.pm.msg) < sizeof(*pmr)) {
 471              		.loc 1 104 0
 472 009c 50419FE5 		ldr	r4, .L30+4
 473 00a0 000B94E5 		ldr	r0, [r4, #2816]
 474              	.LVL34:
 475              	.LBB48:
 476              	.LBB49:
 151:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->head + msgb->data_len) - msgb->tail;
 477              		.loc 2 151 0
 478 00a4 382090E5 		ldr	r2, [r0, #56]
 479 00a8 B433D0E1 		ldrh	r3, [r0, #52]
 480 00ac 033082E0 		add	r3, r2, r3
 481 00b0 3C2090E5 		ldr	r2, [r0, #60]
 482 00b4 033062E0 		rsb	r3, r2, r3
 483              	.LBE49:
 484              	.LBE48:
 104:layer1/prim_pm.c **** 	if (msgb_tailroom(l1s.pm.msg) < sizeof(*pmr)) {
 485              		.loc 1 104 0
 486 00b8 030053E3 		cmp	r3, #3
 487 00bc 0300008A 		bhi	.L24
 106:layer1/prim_pm.c **** 		l1_queue_for_l2(l1s.pm.msg);
 488              		.loc 1 106 0
 489 00c0 FEFFFFEB 		bl	l1_queue_for_l2
 490              	.LVL35:
 108:layer1/prim_pm.c **** 		l1s.pm.msg = l1ctl_msgb_alloc(L1CTL_PM_CONF);
 491              		.loc 1 108 0
 492 00c4 0900A0E3 		mov	r0, #9
 493 00c8 FEFFFFEB 		bl	l1ctl_msgb_alloc
 494 00cc 000B84E5 		str	r0, [r4, #2816]
 495              	.L24:
 111:layer1/prim_pm.c **** 	pmr = msgb_put(l1s.pm.msg, sizeof(*pmr));
 496              		.loc 1 111 0
 497 00d0 1C319FE5 		ldr	r3, .L30+4
 498 00d4 004B93E5 		ldr	r4, [r3, #2816]
 499              	.LVL36:
 500              	.LBB50:
 501              	.LBB51:
 502              	.LBB52:
 503              	.LBB53:
 151:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->head + msgb->data_len) - msgb->tail;
 504              		.loc 2 151 0
 505 00d8 B433D4E1 		ldrh	r3, [r4, #52]
 506              	.LVL37:
 507              	.LBE53:
 508              	.LBE52:
 509 00dc 382084E2 		add	r2, r4, #56
 510 00e0 240092E8 		ldmia	r2, {r2, r5}	@ phole ldm
 511              	.LVL38:
 512              	.LBB55:
 513              	.LBB54:
 514 00e4 032082E0 		add	r2, r2, r3
 515 00e8 022065E0 		rsb	r2, r5, r2
 516              	.LBE54:
 517              	.LBE55:
 181:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_tailroom(msgb) < (int) len)
 518              		.loc 2 181 0
 519 00ec 030052E3 		cmp	r2, #3
 520              	.LVL39:
 182:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "Not enough tailroom msgb_push (%u < %u)\n",
 521              		.loc 2 182 0
 522 00f0 04019FD5 		ldrle	r0, .L30+12
 523 00f4 0410A0D1 		movle	r1, r4
 524 00f8 0430A0D3 		movle	r3, #4
 525 00fc FEFFFFDB 		blle	osmo_panic
 526              	.LVL40:
 527              	.L25:
 184:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->tail += len;
 528              		.loc 2 184 0
 529 0100 3C3094E5 		ldr	r3, [r4, #60]
 530 0104 043083E2 		add	r3, r3, #4
 531 0108 3C3084E5 		str	r3, [r4, #60]
 532              		.loc 2 185 0
 533 010c B633D4E1 		ldrh	r3, [r4, #54]
 534 0110 043083E2 		add	r3, r3, #4
 535 0114 B633C4E1 		strh	r3, [r4, #54]	@ movhi
 536              	.LVL41:
 537              	.LBE51:
 538              	.LBE50:
 539              	.LBB56:
 540              	.LBB57:
 541              		.loc 3 51 0
 542 0118 2634A0E1 		mov	r3, r6, lsr #8
 543 011c 066483E1 		orr	r6, r3, r6, asl #8
 544              	.LVL42:
 545              	.LBE57:
 546              	.LBE56:
 112:layer1/prim_pm.c **** 	pmr->band_arfcn = htons(arfcn);
 547              		.loc 1 112 0
 548 0120 0060C5E5 		strb	r6, [r5, #0]
 549 0124 2664A0E1 		mov	r6, r6, lsr #8
 550 0128 0160C5E5 		strb	r6, [r5, #1]
 114:layer1/prim_pm.c **** 	pmr->pm[0] = dbm2rxlev(agc_inp_dbm8_by_pm(pm_level[0])/8);
 551              		.loc 1 114 0
 552 012c 0700A0E1 		mov	r0, r7
 553 0130 FEFFFFEB 		bl	agc_inp_dbm8_by_pm
 554 0134 0008A0E1 		mov	r0, r0, asl #16
 555 0138 4008A0E1 		mov	r0, r0, asr #16
 556 013c 073080E2 		add	r3, r0, #7
 557 0140 000050E3 		cmp	r0, #0
 558 0144 0300A0B1 		movlt	r0, r3
 559 0148 C001A0E1 		mov	r0, r0, asr #3
 560 014c FEFFFFEB 		bl	dbm2rxlev
 115:layer1/prim_pm.c **** 	if (num_meas > 1)
 561              		.loc 1 115 0
 562 0150 010058E3 		cmp	r8, #1
 118:layer1/prim_pm.c **** 		pmr->pm[1] = 0;
 563              		.loc 1 118 0
 564 0154 0030A093 		movls	r3, #0
 114:layer1/prim_pm.c **** 	pmr->pm[0] = dbm2rxlev(agc_inp_dbm8_by_pm(pm_level[0])/8);
 565              		.loc 1 114 0
 566 0158 0200C5E5 		strb	r0, [r5, #2]
 118:layer1/prim_pm.c **** 		pmr->pm[1] = 0;
 567              		.loc 1 118 0
 568 015c 0330C595 		strlsb	r3, [r5, #3]
 115:layer1/prim_pm.c **** 	if (num_meas > 1)
 569              		.loc 1 115 0
 570 0160 0900009A 		bls	.L27
 116:layer1/prim_pm.c **** 		pmr->pm[1] = dbm2rxlev(agc_inp_dbm8_by_pm(pm_level[1])/8);
 571              		.loc 1 116 0
 572 0164 F200DDE1 		ldrsh	r0, [sp, #2]
 573 0168 FEFFFFEB 		bl	agc_inp_dbm8_by_pm
 574 016c 0008A0E1 		mov	r0, r0, asl #16
 575 0170 4008A0E1 		mov	r0, r0, asr #16
 576 0174 073080E2 		add	r3, r0, #7
 577 0178 000050E3 		cmp	r0, #0
 578 017c 0300A0B1 		movlt	r0, r3
 579 0180 C001A0E1 		mov	r0, r0, asr #3
 580 0184 FEFFFFEB 		bl	dbm2rxlev
 581 0188 0300C5E5 		strb	r0, [r5, #3]
 582              	.L27:
 120:layer1/prim_pm.c **** 	if (l1s.pm.mode == 1) {
 583              		.loc 1 120 0
 584 018c 60409FE5 		ldr	r4, .L30+4
 585              	.LVL43:
 586 0190 F40A94E5 		ldr	r0, [r4, #2804]
 587 0194 010050E3 		cmp	r0, #1
 588 0198 1200001A 		bne	.L28
 121:layer1/prim_pm.c **** 		if (l1s.pm.range.arfcn_next <= l1s.pm.range.arfcn_end) {
 589              		.loc 1 121 0
 590 019c 5C509FE5 		ldr	r5, .L30+16
 591              	.LVL44:
 592 01a0 5C309FE5 		ldr	r3, .L30+20
 593 01a4 B51094E1 		ldrh	r1, [r4, r5]
 594 01a8 B33094E1 		ldrh	r3, [r4, r3]
 595 01ac 010053E1 		cmp	r3, r1
 596 01b0 0400003A 		bcc	.L29
 123:layer1/prim_pm.c **** 			l1s_pm_test(1, l1s.pm.range.arfcn_next);
 597              		.loc 1 123 0
 598 01b4 FEFFFFEB 		bl	l1s_pm_test
 124:layer1/prim_pm.c **** 			l1s.pm.range.arfcn_next++;
 599              		.loc 1 124 0
 600 01b8 B53094E1 		ldrh	r3, [r4, r5]
 601 01bc 013083E2 		add	r3, r3, #1
 602 01c0 B53084E1 		strh	r3, [r4, r5]	@ movhi
 603 01c4 070000EA 		b	.L28
 604              	.L29:
 605              	.LBB58:
 127:layer1/prim_pm.c **** 			struct l1ctl_hdr *l1h = l1s.pm.msg->l1h;
 606              		.loc 1 127 0
 607 01c8 000B94E5 		ldr	r0, [r4, #2816]
 608 01cc 103090E5 		ldr	r3, [r0, #16]
 609              	.LVL45:
 128:layer1/prim_pm.c **** 			l1h->flags |= L1CTL_F_DONE;
 610              		.loc 1 128 0
 611 01d0 0120D3E5 		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 612 01d4 012082E3 		orr	r2, r2, #1
 613 01d8 0120C3E5 		strb	r2, [r3, #1]
 129:layer1/prim_pm.c **** 			l1_queue_for_l2(l1s.pm.msg);
 614              		.loc 1 129 0
 615 01dc FEFFFFEB 		bl	l1_queue_for_l2
 616              	.LVL46:
 130:layer1/prim_pm.c **** 			l1s.pm.msg = NULL;
 617              		.loc 1 130 0
 618 01e0 0030A0E3 		mov	r3, #0
 619 01e4 003B84E5 		str	r3, [r4, #2816]
 620              	.L28:
 621              	.LBE58:
 135:layer1/prim_pm.c **** }
 622              		.loc 1 135 0
 623 01e8 0000A0E3 		mov	r0, #0
 624 01ec F881BDE8 		ldmfd	sp!, {r3, r4, r5, r6, r7, r8, pc}
 625              	.L31:
 626              		.align	2
 627              	.L30:
 628 01f0 00000000 		.word	dsp_api
 629 01f4 00000000 		.word	l1s
 630 01f8 33000000 		.word	.LC1
 631 01fc 00000000 		.word	.LC0
 632 0200 FA0A0000 		.word	2810
 633 0204 FC0A0000 		.word	2812
 634              		.cfi_endproc
 635              	.LFE61:
 637              		.global	neigh_pm_sched_set
 638              		.section	.rodata
 639              		.align	2
 640              		.set	.LANCHOR0,. + 0
 643              	pm_sched_set:
 644 0000 00000000 		.word	l1s_pm_cmd
 645 0004 01       		.byte	1
 646 0005 00       		.byte	0
 647 0006 0000     		.space	2
 648 0008 0000     		.short	0
 649 000a 0300     		.short	3
 650 000c 00000000 		.word	0
 651 0010 00       		.byte	0
 652 0011 00       		.byte	0
 653 0012 00000000 		.space	6
 653      0000
 654 0018 00000000 		.word	0
 655 001c 00       		.byte	0
 656 001d 00       		.byte	0
 657 001e 00000000 		.space	6
 657      0000
 658 0024 00000000 		.word	l1s_pm_resp
 659 0028 01       		.byte	1
 660 0029 00       		.byte	0
 661 002a 0000     		.space	2
 662 002c FCFF     		.short	-4
 663 002e 0000     		.short	0
 664 0030 00000000 		.word	0
 665 0034 00       		.byte	0
 666 0035 00       		.byte	0
 667 0036 00000000 		.space	6
 667      0000
 668 003c 00000000 		.word	tdma_end_set
 669 0040 00       		.byte	0
 670 0041 00       		.byte	0
 671 0042 00000000 		.space	6
 671      0000
 674              	neigh_pm_sched_set:
 675 0048 00000000 		.word	l1s_neigh_pm_cmd
 676 004c 01       		.byte	1
 677 004d 00       		.byte	0
 678 004e 0000     		.space	2
 679 0050 0000     		.short	0
 680 0052 0300     		.short	3
 681 0054 00000000 		.word	0
 682 0058 00       		.byte	0
 683 0059 00       		.byte	0
 684 005a 00000000 		.space	6
 684      0000
 685 0060 00000000 		.word	0
 686 0064 00       		.byte	0
 687 0065 00       		.byte	0
 688 0066 00000000 		.space	6
 688      0000
 689 006c 00000000 		.word	l1s_neigh_pm_resp
 690 0070 01       		.byte	1
 691 0071 00       		.byte	0
 692 0072 0000     		.space	2
 693 0074 FCFF     		.short	-4
 694 0076 0000     		.short	0
 695 0078 00000000 		.word	0
 696 007c 00       		.byte	0
 697 007d 00       		.byte	0
 698 007e 00000000 		.space	6
 698      0000
 699 0084 00000000 		.word	tdma_end_set
 700 0088 00       		.byte	0
 701 0089 00       		.byte	0
 702 008a 00000000 		.space	6
 702      0000
 703              		.section	.rodata.str1.1,"aMS",%progbits,1
 704              	.LC0:
 705 0000 6D736762 		.ascii	"msgb(%p): Not enough tailroom msgb_push (%u < %u)\012"
 705      28257029 
 705      3A204E6F 
 705      7420656E 
 705      6F756768 
 706 0032 00       		.ascii	"\000"
 707              	.LC1:
 708 0033 504D204D 		.ascii	"PM MEAS: ARFCN=%u, %-4d dBm at baseband, %-4d dBm a"
 708      4541533A 
 708      20415246 
 708      434E3D25 
 708      752C2025 
 709 0066 74205246 		.ascii	"t RF\012\000"
 709      0A00
 710              		.text
 711              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 prim_pm.c
     /tmp/ccbm11y5.s:12     .text.l1s_neigh_pm_resp:0000000000000000 $a
     /tmp/ccbm11y5.s:14     .text.l1s_neigh_pm_resp:0000000000000000 l1s_neigh_pm_resp
     /tmp/ccbm11y5.s:203    .text.l1s_neigh_pm_resp:000000000000015c $d
     /tmp/ccbm11y5.s:211    .text.l1s_pm_cmd:0000000000000000 $a
     /tmp/ccbm11y5.s:213    .text.l1s_pm_cmd:0000000000000000 l1s_pm_cmd
     /tmp/ccbm11y5.s:262    .text.l1s_pm_cmd:000000000000004c $d
     /tmp/ccbm11y5.s:267    .text.l1s_neigh_pm_cmd:0000000000000000 $a
     /tmp/ccbm11y5.s:269    .text.l1s_neigh_pm_cmd:0000000000000000 l1s_neigh_pm_cmd
     /tmp/ccbm11y5.s:326    .text.l1s_neigh_pm_cmd:000000000000006c $d
     /tmp/ccbm11y5.s:332    .text.l1s_pm_test:0000000000000000 $a
     /tmp/ccbm11y5.s:335    .text.l1s_pm_test:0000000000000000 l1s_pm_test
     /tmp/ccbm11y5.s:374    .text.l1s_pm_test:000000000000002c $d
     /tmp/ccbm11y5.s:379    .text.l1s_pm_resp:0000000000000000 $a
     /tmp/ccbm11y5.s:381    .text.l1s_pm_resp:0000000000000000 l1s_pm_resp
     /tmp/ccbm11y5.s:628    .text.l1s_pm_resp:00000000000001f0 $d
     /tmp/ccbm11y5.s:674    .rodata:0000000000000048 neigh_pm_sched_set
     /tmp/ccbm11y5.s:639    .rodata:0000000000000000 $d
     /tmp/ccbm11y5.s:643    .rodata:0000000000000000 pm_sched_set
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
agc_inp_dbm8_by_pm
dbm2rxlev
l1ctl_msgb_alloc
l1_queue_for_l2
osmo_panic
dsp_api
l1s
rffe_compute_gain
l1s_rx_win_ctrl
rffe_get_gain
rffe_set_gain
tdma_schedule_set
printf
tdma_end_set
